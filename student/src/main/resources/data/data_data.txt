{"problemSetProblem": {"id": "965458856133562368", "label": "习题1.8", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 100, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "二分查找", "content": "本题要求实现二分查找算法。\n\n### 函数接口定义：\n```c++\nPosition BinarySearch( List L, ElementType X );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n```\n`L`是用户传入的一个线性表，其中`ElementType`元素可以通过$$>$$、$$==$$、$$<$$进行比较，并且题目保证传入的数据是递增有序的。函数`BinarySearch`要查找`X`在`Data`中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记`NotFound`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 10\n#define NotFound 0\ntypedef int ElementType;\n\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n\nList ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */\nPosition BinarySearch( List L, ElementType X );\n\nint main()\n{\n    List L;\n    ElementType X;\n    Position P;\n\n    L = ReadInput();\n    scanf(\"%d\", &X);\n    P = BinarySearch( L, X );\n    printf(\"%d\\n\", P);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：\n```in\n5\n12 31 55 89 101\n31\n```\n\n### 输出样例1：\n```out\n2\n```\n\n### 输入样例2：\n```\n3\n26 78 233\n31\n```\n\n### 输出样例2：\n```\n0\n```\n\n**鸣谢宁波大学 Eyre-lemon-郎俊杰 同学修正原题！**", "type": "CODE_COMPLETION", "author": "陈越", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "906", "description": "本题要求实现二分查找算法。\n\n### 函数接口定义：\n```c++\nPosition BinarySearch( List L, ElementType X );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n```\n`L`是用户传入的一个线性表，其中`ElementType`元素可以通过$$>$$、$$==$$、$$<$$进行比较，并且题目保证传入的数据是递增有序的。函数`BinarySearch`要查找`X`在`Data`中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记`NotFound`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 10\n#define NotFound 0\ntypedef int ElementType;\n\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n\nList ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */\nPosition BinarySearch( List L, ElementType X );\n\nint main()\n{\n    List L;\n    ElementType X;\n    Position P;\n\n    L = ReadInput();\n    scanf(\"%d\", &X);\n    P = BinarySearch( L, X );\n    printf(\"%d\\n\", P);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：\n```in\n5\n12 31 55 89 101\n31\n```\n\n### 输出样例1：\n```out\n2\n```\n\n### 输入样例2：\n```\n3\n26 78 233\n31\n```\n\n### 输出样例2：\n```\n0\n```\n\n**鸣谢宁波大学 Eyre-lemon-郎俊杰 同学修正原题！**"}}
{"problemSetProblem": {"id": "965573204499779584", "label": "习题1.9", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 1000, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "有序数组的插入", "content": "本题要求将任一给定元素插入从大到小排好序的数组中合适的位置，以保持结果依然有序。\n\n### 函数接口定义：\n```c++\nbool Insert( List L, ElementType X );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n```\n\n`L`是用户传入的一个线性表，其中`ElementType`元素可以通过$$>$$、$$==$$、$$<$$进行比较，并且题目保证传入的数据是递减有序的。函数`Insert`要将`X`插入`Data[]`中合适的位置，以保持结果依然有序（注意：元素从下标0开始存储）。但如果`X`已经在`Data[]`中了，就不要插入，返回失败的标记`false`；如果插入成功，则返回`true`。另外，因为`Data[]`中最多只能存`MAXSIZE`个元素，所以如果插入新元素之前已经满了，也不要插入，而是返回失败的标记`false`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 10\ntypedef enum {false, true} bool;\ntypedef int ElementType;\n\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n\nList ReadInput(); /* 裁判实现，细节不表。元素从下标0开始存储 */\nvoid PrintList( List L ); /* 裁判实现，细节不表 */\nbool Insert( List L, ElementType X );\n\nint main()\n{\n    List L;\n    ElementType X;\n\n    L = ReadInput();\n    scanf(\"%d\", &X);\n    if ( Insert( L, X ) == false )\n        printf(\"Insertion failed.\\n\");\n    PrintList( L );\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：\n```in\n5\n35 12 8 7 3\n10\n```\n\n### 输出样例1：\n```out\n35 12 10 8 7 3\nLast = 5\n```\n\n### 输入样例2：\n```in\n6\n35 12 10 8 7 3\n8\n```\n\n### 输出样例2：\n```out\nInsertion failed.\n35 12 10 8 7 3\nLast = 5\n```\n", "type": "CODE_COMPLETION", "author": "陈越", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "965569933525684224", "description": "本题要求将任一给定元素插入从大到小排好序的数组中合适的位置，以保持结果依然有序。\n\n### 函数接口定义：\n```c++\nbool Insert( List L, ElementType X );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n```\n\n`L`是用户传入的一个线性表，其中`ElementType`元素可以通过$$>$$、$$==$$、$$<$$进行比较，并且题目保证传入的数据是递减有序的。函数`Insert`要将`X`插入`Data[]`中合适的位置，以保持结果依然有序（注意：元素从下标0开始存储）。但如果`X`已经在`Data[]`中了，就不要插入，返回失败的标记`false`；如果插入成功，则返回`true`。另外，因为`Data[]`中最多只能存`MAXSIZE`个元素，所以如果插入新元素之前已经满了，也不要插入，而是返回失败的标记`false`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 10\ntypedef enum {false, true} bool;\ntypedef int ElementType;\n\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n\nList ReadInput(); /* 裁判实现，细节不表。元素从下标0开始存储 */\nvoid PrintList( List L ); /* 裁判实现，细节不表 */\nbool Insert( List L, ElementType X );\n\nint main()\n{\n    List L;\n    ElementType X;\n\n    L = ReadInput();\n    scanf(\"%d\", &X);\n    if ( Insert( L, X ) == false )\n        printf(\"Insertion failed.\\n\");\n    PrintList( L );\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：\n```in\n5\n35 12 8 7 3\n10\n```\n\n### 输出样例1：\n```out\n35 12 10 8 7 3\nLast = 5\n```\n\n### 输入样例2：\n```in\n6\n35 12 10 8 7 3\n8\n```\n\n### 输出样例2：\n```out\nInsertion failed.\n35 12 10 8 7 3\nLast = 5\n```\n"}}
{"problemSetProblem": {"id": "5726", "label": "习题2.4", "score": 15, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "递增的整数序列链表的插入", "content": "本题要求实现一个函数，在递增的整数序列链表（带头结点）中插入一个新整数，并保持该序列的有序性。\n\n### 函数接口定义：\n```c++\nList Insert( List L, ElementType X );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data; /* 存储结点数据 */\n    PtrToNode   Next; /* 指向下一个结点的指针 */\n};\ntypedef PtrToNode List; /* 定义单链表类型 */\n```\n`L`是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数`Insert`要将`X`插入`L`，并保持该序列的有序性，返回插入后的链表头指针。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int ElementType;\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\n\nList Read(); /* 细节在此不表 */\nvoid Print( List L ); /* 细节在此不表 */\n\nList Insert( List L, ElementType X );\n\nint main()\n{\n    List L;\n    ElementType X;\n    L = Read();\n    scanf(\"%d\", &X);\n    L = Insert(L, X);\n    Print(L);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n5\n1 2 4 5 6\n3\n```\n\n### 输出样例：\n```out\n1 2 3 4 5 6 \n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1388", "description": "本题要求实现一个函数，在递增的整数序列链表（带头结点）中插入一个新整数，并保持该序列的有序性。\n\n### 函数接口定义：\n```c++\nList Insert( List L, ElementType X );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data; /* 存储结点数据 */\n    PtrToNode   Next; /* 指向下一个结点的指针 */\n};\ntypedef PtrToNode List; /* 定义单链表类型 */\n```\n`L`是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数`Insert`要将`X`插入`L`，并保持该序列的有序性，返回插入后的链表头指针。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int ElementType;\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\n\nList Read(); /* 细节在此不表 */\nvoid Print( List L ); /* 细节在此不表 */\n\nList Insert( List L, ElementType X );\n\nint main()\n{\n    List L;\n    ElementType X;\n    L = Read();\n    scanf(\"%d\", &X);\n    L = Insert(L, X);\n    Print(L);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n5\n1 2 4 5 6\n3\n```\n\n### 输出样例：\n```out\n1 2 3 4 5 6 \n```"}}
{"problemSetProblem": {"id": "5803", "label": "习题2.5", "score": 15, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "两个有序链表序列的合并", "content": "本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。\n\n### 函数接口定义：\n```c++\nList Merge( List L1, List L2 );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data; /* 存储结点数据 */\n    PtrToNode   Next; /* 指向下一个结点的指针 */\n};\ntypedef PtrToNode List; /* 定义单链表类型 */\n```\n`L1`和`L2`是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数`Merge`要将`L1`和`L2`合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int ElementType;\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\n\nList Read(); /* 细节在此不表 */\nvoid Print( List L ); /* 细节在此不表；空链表将输出NULL */\n\nList Merge( List L1, List L2 );\n\nint main()\n{\n    List L1, L2, L;\n    L1 = Read();\n    L2 = Read();\n    L = Merge(L1, L2);\n    Print(L);\n    Print(L1);\n    Print(L2);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n3\n1 3 5\n5\n2 4 6 8 10\n```\n\n### 输出样例：\n```out\n1 2 3 4 5 6 8 10 \nNULL\nNULL\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1389", "description": "本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。\n\n### 函数接口定义：\n```c++\nList Merge( List L1, List L2 );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data; /* 存储结点数据 */\n    PtrToNode   Next; /* 指向下一个结点的指针 */\n};\ntypedef PtrToNode List; /* 定义单链表类型 */\n```\n`L1`和`L2`是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数`Merge`要将`L1`和`L2`合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int ElementType;\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\n\nList Read(); /* 细节在此不表 */\nvoid Print( List L ); /* 细节在此不表；空链表将输出NULL */\n\nList Merge( List L1, List L2 );\n\nint main()\n{\n    List L1, L2, L;\n    L1 = Read();\n    L2 = Read();\n    L = Merge(L1, L2);\n    Print(L);\n    Print(L1);\n    Print(L2);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n3\n1 3 5\n5\n2 4 6 8 10\n```\n\n### 输出样例：\n```out\n1 2 3 4 5 6 8 10 \nNULL\nNULL\n```"}}
{"problemSetProblem": {"id": "5804", "label": "习题2.6", "score": 15, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "递归求简单交错幂级数的部分和", "content": "本题要求实现一个函数，计算下列简单交错幂级数的部分和：\n\n$$ f(x, n) = x - x^2 + x^3 - x^4 + \\cdots + (-1)^{n-1}x^n $$\n\n\n### 函数接口定义：\n```c++\ndouble fn( double x, int n );\n```\n其中题目保证传入的`n`是正整数，并且输入输出都在双精度范围内。函数`fn`应返回上述级数的部分和。建议尝试用递归实现。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\ndouble fn( double x, int n );\n\nint main()\n{\n    double x;\n    int n;\n    \n    scanf(\"%lf %d\", &x, &n);\n    printf(\"%.2f\\n\", fn(x,n));\n    \n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n0.5 12\n```\n\n### 输出样例：\n```out\n0.33\n```", "type": "CODE_COMPLETION", "author": "张高燕", "authorOrganization": {"id": "2", "name": "浙大城市学院", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "451", "description": "本题要求实现一个函数，计算下列简单交错幂级数的部分和：\n\n$$ f(x, n) = x - x^2 + x^3 - x^4 + \\cdots + (-1)^{n-1}x^n $$\n\n\n### 函数接口定义：\n```c++\ndouble fn( double x, int n );\n```\n其中题目保证传入的`n`是正整数，并且输入输出都在双精度范围内。函数`fn`应返回上述级数的部分和。建议尝试用递归实现。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\ndouble fn( double x, int n );\n\nint main()\n{\n    double x;\n    int n;\n    \n    scanf(\"%lf %d\", &x, &n);\n    printf(\"%.2f\\n\", fn(x,n));\n    \n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n0.5 12\n```\n\n### 输出样例：\n```out\n0.33\n```"}}
{"problemSetProblem": {"id": "5806", "label": "习题2.7", "score": 15, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "弹球距离", "content": "设有一个球从高度为$$h$$米的地方落下，碰到地面后又弹到高度为原来$$p$$倍的位置，然后又落下，再弹起，再落下…。请编写函数求初始高度为$$h$$的球下落后到基本停下来（高度小于给定阈值TOL）时在空中所经过的路程总和。\n\n### 函数接口定义：\n```c++\ndouble dist( double h, double p );\n```\n\n其中`h`是球的初始高度，`p`是球弹起高度与弹起前落下高度的比值；函数`dist`要返回球下落后到基本停下来时在空中所经过的路程总和。注意：当弹起的高度小于裁判程序定义的常数`TOL`时，弹起的距离不计算在内。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#define TOL 1E-2\n\ndouble dist( double h, double p );\n\nint main()\n{\n    double h, p, d;\n    scanf(\"%lf %lf\", &h, &p);\n    d = dist(h, p);\n    printf(\"%.6f\\n\", d);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n1.0 0.4\n```\n\n### 输出样例：\n```out\n2.319680\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1390", "description": "设有一个球从高度为$$h$$米的地方落下，碰到地面后又弹到高度为原来$$p$$倍的位置，然后又落下，再弹起，再落下…。请编写函数求初始高度为$$h$$的球下落后到基本停下来（高度小于给定阈值TOL）时在空中所经过的路程总和。\n\n### 函数接口定义：\n```c++\ndouble dist( double h, double p );\n```\n\n其中`h`是球的初始高度，`p`是球弹起高度与弹起前落下高度的比值；函数`dist`要返回球下落后到基本停下来时在空中所经过的路程总和。注意：当弹起的高度小于裁判程序定义的常数`TOL`时，弹起的距离不计算在内。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#define TOL 1E-2\n\ndouble dist( double h, double p );\n\nint main()\n{\n    double h, p, d;\n    scanf(\"%lf %lf\", &h, &p);\n    d = dist(h, p);\n    printf(\"%.6f\\n\", d);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n1.0 0.4\n```\n\n### 输出样例：\n```out\n2.319680\n```"}}
{"problemSetProblem": {"id": "966247795744329728", "label": "习题3.3", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 200, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "线性表元素的区间删除", "content": "给定一个顺序存储的线性表，请设计一个函数删除所有值大于min而且小于max的元素。删除后表中剩余元素保持顺序存储，并且相对位置不能改变。\n\n### 函数接口定义：\n```c++\nList Delete( List L, ElementType minD, ElementType maxD );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n```\n\n`L`是用户传入的一个线性表，其中`ElementType`元素可以通过$$>$$、$$==$$、$$<$$进行比较；`minD`和`maxD`分别为待删除元素的值域的下、上界。函数`Delete`应将`Data[]`中所有值大于`minD`而且小于`maxD`的元素删除，同时保证表中剩余元素保持顺序存储，并且相对位置不变，最后返回删除后的表。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\n#define MAXSIZE 20\ntypedef int ElementType;\n\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n\nList ReadInput(); /* 裁判实现，细节不表。元素从下标0开始存储 */\nvoid PrintList( List L ); /* 裁判实现，细节不表 */\nList Delete( List L, ElementType minD, ElementType maxD );\n\nint main()\n{\n    List L;\n    ElementType minD, maxD;\n    int i;\n\n    L = ReadInput();\n    scanf(\"%d %d\", &minD, &maxD);\n    L = Delete( L, minD, maxD );\n    PrintList( L );\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n10\n4 -8 2 12 1 5 9 3 3 10\n0 4\n```\n\n### 输出样例：\n```out\n4 -8 12 5 9 10 \n```\n\n", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "966247445368950784", "description": "给定一个顺序存储的线性表，请设计一个函数删除所有值大于min而且小于max的元素。删除后表中剩余元素保持顺序存储，并且相对位置不能改变。\n\n### 函数接口定义：\n```c++\nList Delete( List L, ElementType minD, ElementType maxD );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n```\n\n`L`是用户传入的一个线性表，其中`ElementType`元素可以通过$$>$$、$$==$$、$$<$$进行比较；`minD`和`maxD`分别为待删除元素的值域的下、上界。函数`Delete`应将`Data[]`中所有值大于`minD`而且小于`maxD`的元素删除，同时保证表中剩余元素保持顺序存储，并且相对位置不变，最后返回删除后的表。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\n#define MAXSIZE 20\ntypedef int ElementType;\n\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data[MAXSIZE];\n    Position Last; /* 保存线性表中最后一个元素的位置 */\n};\n\nList ReadInput(); /* 裁判实现，细节不表。元素从下标0开始存储 */\nvoid PrintList( List L ); /* 裁判实现，细节不表 */\nList Delete( List L, ElementType minD, ElementType maxD );\n\nint main()\n{\n    List L;\n    ElementType minD, maxD;\n    int i;\n\n    L = ReadInput();\n    scanf(\"%d %d\", &minD, &maxD);\n    L = Delete( L, minD, maxD );\n    PrintList( L );\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n10\n4 -8 2 12 1 5 9 3 3 10\n0 4\n```\n\n### 输出样例：\n```out\n4 -8 12 5 9 10 \n```\n\n"}}
{"problemSetProblem": {"id": "966235055998885888", "label": "习题3.5", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "求链表的倒数第m个元素", "content": "请设计时间和空间上都尽可能高效的算法，在不改变链表的前提下，求链式存储的线性表的倒数第m（$$>0$$）个元素。\n\n### 函数接口定义：\n```c++\nElementType Find( List L, int m );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data; /* 存储结点数据 */\n    PtrToNode   Next; /* 指向下一个结点的指针 */\n};\ntypedef PtrToNode List; /* 定义单链表类型 */\n```\n`L`是给定的带头结点的单链表；函数`Find`要将`L`的倒数第`m`个元素返回，并不改变原链表。如果这样的元素不存在，则返回一个错误标志`ERROR`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\n\ntypedef int ElementType;\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\n\nList Read(); /* 细节在此不表 */\nvoid Print( List L ); /* 细节在此不表 */\n\nElementType Find( List L, int m );\n\nint main()\n{\n    List L;\n    int m;\n    L = Read();\n    scanf(\"%d\", &m);\n    printf(\"%d\\n\", Find(L,m));\n    Print(L);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n5\n1 2 4 5 6\n3\n```\n\n### 输出样例：\n```out\n4\n1 2 4 5 6 \n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1493", "description": "请设计时间和空间上都尽可能高效的算法，在不改变链表的前提下，求链式存储的线性表的倒数第m（$$>0$$）个元素。\n\n### 函数接口定义：\n```c++\nElementType Find( List L, int m );\n```\n\n其中`List`结构定义如下：\n```c++\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data; /* 存储结点数据 */\n    PtrToNode   Next; /* 指向下一个结点的指针 */\n};\ntypedef PtrToNode List; /* 定义单链表类型 */\n```\n`L`是给定的带头结点的单链表；函数`Find`要将`L`的倒数第`m`个元素返回，并不改变原链表。如果这样的元素不存在，则返回一个错误标志`ERROR`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\n\ntypedef int ElementType;\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\n\nList Read(); /* 细节在此不表 */\nvoid Print( List L ); /* 细节在此不表 */\n\nElementType Find( List L, int m );\n\nint main()\n{\n    List L;\n    int m;\n    L = Read();\n    scanf(\"%d\", &m);\n    printf(\"%d\\n\", Find(L,m));\n    Print(L);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n5\n1 2 4 5 6\n3\n```\n\n### 输出样例：\n```out\n4\n1 2 4 5 6 \n```"}}
{"problemSetProblem": {"id": "6085", "label": "习题3.12", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "另类循环队列", "content": "如果用一个循环数组表示队列，并且只设队列头指针Front，不设尾指针Rear，而是另设Count记录队列中元素个数。请编写算法实现队列的入队和出队操作。\n\n### 函数接口定义：\n```c++\nbool AddQ( Queue Q, ElementType X );\nElementType DeleteQ( Queue Q );\n```\n\n其中`Queue`结构定义如下：\n\n```c++\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;  /* 存储元素的数组   */\n    Position Front;     /* 队列的头指针     */\n    int Count;          /* 队列中元素个数   */\n    int MaxSize;        /* 队列最大容量     */\n};\ntypedef PtrToQNode Queue; \n```\n注意：如果队列已满，`AddQ`函数必须输出“Queue Full”并且返回false；如果队列是空的，则`DeleteQ`函数必须输出“Queue Empty”，并且返回ERROR。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\ntypedef int ElementType;\ntypedef enum { addq, delq, end } Operation;\ntypedef enum { false, true } bool;\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;  /* 存储元素的数组   */\n    Position Front;     /* 队列的头、尾指针 */\n    int Count;          /* 队列中元素个数   */\n    int MaxSize;        /* 队列最大容量     */\n};\ntypedef PtrToQNode Queue; \n\nQueue CreateQueue( int MaxSize )\n{\n    Queue Q = (Queue)malloc(sizeof(struct QNode));\n    Q->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\n    Q->Front = 0;\n    Q->Count = 0;\n    Q->MaxSize = MaxSize;\n    return Q;\n}\n\nbool AddQ( Queue Q, ElementType X );\nElementType DeleteQ( Queue Q );\n\nOperation GetOp();  /* 裁判实现，细节不表 */\n\nint main()\n{\n    ElementType X;\n    Queue Q;\n    int N, done = 0;\n\n    scanf(\"%d\", &N);\n    Q = CreateQueue(N);\n    while ( !done ) {\n        switch( GetOp() ) {\n        case addq: \n            scanf(\"%d\", &X);\n            AddQ(Q, X);\n            break;\n        case delq:\n            X = DeleteQ(Q);\n            if ( X!=ERROR ) printf(\"%d is out\\n\", X);\n            break;\n        case end:\n            while (Q->Count) printf(\"%d \", DeleteQ(Q));\n            done = 1;\n            break;\n        }\n    }\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n4\nDel\nAdd 5\nAdd 4\nAdd 3\nDel\nDel\nAdd 2\nAdd 1\nAdd 0\nAdd 10\nEnd\n```\n\n### 输出样例：\n```out\nQueue Empty\n5 is out\n4 is out\nQueue Full\n3 2 1 0 \n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1506", "description": "如果用一个循环数组表示队列，并且只设队列头指针Front，不设尾指针Rear，而是另设Count记录队列中元素个数。请编写算法实现队列的入队和出队操作。\n\n### 函数接口定义：\n```c++\nbool AddQ( Queue Q, ElementType X );\nElementType DeleteQ( Queue Q );\n```\n\n其中`Queue`结构定义如下：\n\n```c++\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;  /* 存储元素的数组   */\n    Position Front;     /* 队列的头指针     */\n    int Count;          /* 队列中元素个数   */\n    int MaxSize;        /* 队列最大容量     */\n};\ntypedef PtrToQNode Queue; \n```\n注意：如果队列已满，`AddQ`函数必须输出“Queue Full”并且返回false；如果队列是空的，则`DeleteQ`函数必须输出“Queue Empty”，并且返回ERROR。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\ntypedef int ElementType;\ntypedef enum { addq, delq, end } Operation;\ntypedef enum { false, true } bool;\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;  /* 存储元素的数组   */\n    Position Front;     /* 队列的头、尾指针 */\n    int Count;          /* 队列中元素个数   */\n    int MaxSize;        /* 队列最大容量     */\n};\ntypedef PtrToQNode Queue; \n\nQueue CreateQueue( int MaxSize )\n{\n    Queue Q = (Queue)malloc(sizeof(struct QNode));\n    Q->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\n    Q->Front = 0;\n    Q->Count = 0;\n    Q->MaxSize = MaxSize;\n    return Q;\n}\n\nbool AddQ( Queue Q, ElementType X );\nElementType DeleteQ( Queue Q );\n\nOperation GetOp();  /* 裁判实现，细节不表 */\n\nint main()\n{\n    ElementType X;\n    Queue Q;\n    int N, done = 0;\n\n    scanf(\"%d\", &N);\n    Q = CreateQueue(N);\n    while ( !done ) {\n        switch( GetOp() ) {\n        case addq: \n            scanf(\"%d\", &X);\n            AddQ(Q, X);\n            break;\n        case delq:\n            X = DeleteQ(Q);\n            if ( X!=ERROR ) printf(\"%d is out\\n\", X);\n            break;\n        case end:\n            while (Q->Count) printf(\"%d \", DeleteQ(Q));\n            done = 1;\n            break;\n        }\n    }\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n4\nDel\nAdd 5\nAdd 4\nAdd 3\nDel\nDel\nAdd 2\nAdd 1\nAdd 0\nAdd 10\nEnd\n```\n\n### 输出样例：\n```out\nQueue Empty\n5 is out\n4 is out\nQueue Full\n3 2 1 0 \n```"}}
{"problemSetProblem": {"id": "6096", "label": "习题3.13", "score": 25, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "双端队列", "content": "双端队列（deque，即double-ended queue的缩写）是一种具有队列和栈性质的数据结构，即可以（也只能）在线性表的两端进行插入和删除。若以顺序存储方式实现双端队列，请编写例程实现下列操作：\n\n- `Push(X,D)`：将元素`X`插入到双端队列`D`的头；\n- `Pop(D)`：删除双端队列`D`的头元素，并返回；\n- `Inject(X,D)`：将元素`X`插入到双端队列`D`的尾部；\n- `Eject(D)`：删除双端队列`D`的尾部元素，并返回。\n\n### 函数接口定义：\n```c++\nbool Push( ElementType X, Deque D );\nElementType Pop( Deque D );\nbool Inject( ElementType X, Deque D );\nElementType Eject( Deque D );\n```\n\n其中`Deque`结构定义如下：\n\n```c++\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;      /* 存储元素的数组   */\n    Position Front, Rear;   /* 队列的头、尾指针 */\n    int MaxSize;            /* 队列最大容量     */\n};\ntypedef PtrToQNode Deque; \n```\n注意：`Push`和`Inject`应该在正常执行完操作后返回true，或者在出现非正常情况时返回false。当`Front`和`Rear`相等时队列为空，`Pop`和`Eject`必须返回由裁判程序定义的`ERROR`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\ntypedef int ElementType;\ntypedef enum { push, pop, inject, eject, end } Operation;\ntypedef enum { false, true } bool;\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;      /* 存储元素的数组   */\n    Position Front, Rear;   /* 队列的头、尾指针 */\n    int MaxSize;            /* 队列最大容量     */\n};\ntypedef PtrToQNode Deque; \n\nDeque CreateDeque( int MaxSize )\n{   /* 注意：为区分空队列和满队列，需要多开辟一个空间 */\n    Deque D = (Deque)malloc(sizeof(struct QNode));\n    MaxSize++;\n    D->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\n    D->Front = D->Rear = 0;\n    D->MaxSize = MaxSize;\n    return D;\n}\n\nbool Push( ElementType X, Deque D );\nElementType Pop( Deque D );\nbool Inject( ElementType X, Deque D );\nElementType Eject( Deque D );\n\nOperation GetOp();          /* 裁判实现，细节不表 */\nvoid PrintDeque( Deque D ); /* 裁判实现，细节不表 */\n\nint main()\n{\n    ElementType X;\n    Deque D;\n    int N, done = 0;\n\n    scanf(\"%d\", &N);\n    D = CreateDeque(N);\n    while (!done) {\n        switch(GetOp()) {\n        case push: \n            scanf(\"%d\", &X);\n            if (!Push(X, D)) printf(\"Deque is Full!\\n\");\n            break;\n        case pop:\n            X = Pop(D);\n            if ( X==ERROR ) printf(\"Deque is Empty!\\n\");\n            else printf(\"%d is out\\n\", X);\n            break;\n        case inject: \n            scanf(\"%d\", &X);\n            if (!Inject(X, D)) printf(\"Deque is Full!\\n\");\n            break;\n        case eject:\n            X = Eject(D);\n            if ( X==ERROR ) printf(\"Deque is Empty!\\n\");\n            else printf(\"%d is out\\n\", X);\n            break;\n        case end:\n            PrintDeque(D);\n            done = 1;\n            break;\n        }\n    }\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n3\nPop\nInject 1\nPop\nEject\nPush 2\nPush 3\nEject\nInject 4\nInject 5\nInject 6\nPush 7\nPop\nEnd\n```\n\n### 输出样例：\n```out\nDeque is Empty!\n1 is out\nDeque is Empty!\n2 is out\nDeque is Full!\nDeque is Full!\n3 is out\nInside Deque: 4 5\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1507", "description": "双端队列（deque，即double-ended queue的缩写）是一种具有队列和栈性质的数据结构，即可以（也只能）在线性表的两端进行插入和删除。若以顺序存储方式实现双端队列，请编写例程实现下列操作：\n\n- `Push(X,D)`：将元素`X`插入到双端队列`D`的头；\n- `Pop(D)`：删除双端队列`D`的头元素，并返回；\n- `Inject(X,D)`：将元素`X`插入到双端队列`D`的尾部；\n- `Eject(D)`：删除双端队列`D`的尾部元素，并返回。\n\n### 函数接口定义：\n```c++\nbool Push( ElementType X, Deque D );\nElementType Pop( Deque D );\nbool Inject( ElementType X, Deque D );\nElementType Eject( Deque D );\n```\n\n其中`Deque`结构定义如下：\n\n```c++\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;      /* 存储元素的数组   */\n    Position Front, Rear;   /* 队列的头、尾指针 */\n    int MaxSize;            /* 队列最大容量     */\n};\ntypedef PtrToQNode Deque; \n```\n注意：`Push`和`Inject`应该在正常执行完操作后返回true，或者在出现非正常情况时返回false。当`Front`和`Rear`相等时队列为空，`Pop`和`Eject`必须返回由裁判程序定义的`ERROR`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\ntypedef int ElementType;\ntypedef enum { push, pop, inject, eject, end } Operation;\ntypedef enum { false, true } bool;\ntypedef int Position;\ntypedef struct QNode *PtrToQNode;\nstruct QNode {\n    ElementType *Data;      /* 存储元素的数组   */\n    Position Front, Rear;   /* 队列的头、尾指针 */\n    int MaxSize;            /* 队列最大容量     */\n};\ntypedef PtrToQNode Deque; \n\nDeque CreateDeque( int MaxSize )\n{   /* 注意：为区分空队列和满队列，需要多开辟一个空间 */\n    Deque D = (Deque)malloc(sizeof(struct QNode));\n    MaxSize++;\n    D->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\n    D->Front = D->Rear = 0;\n    D->MaxSize = MaxSize;\n    return D;\n}\n\nbool Push( ElementType X, Deque D );\nElementType Pop( Deque D );\nbool Inject( ElementType X, Deque D );\nElementType Eject( Deque D );\n\nOperation GetOp();          /* 裁判实现，细节不表 */\nvoid PrintDeque( Deque D ); /* 裁判实现，细节不表 */\n\nint main()\n{\n    ElementType X;\n    Deque D;\n    int N, done = 0;\n\n    scanf(\"%d\", &N);\n    D = CreateDeque(N);\n    while (!done) {\n        switch(GetOp()) {\n        case push: \n            scanf(\"%d\", &X);\n            if (!Push(X, D)) printf(\"Deque is Full!\\n\");\n            break;\n        case pop:\n            X = Pop(D);\n            if ( X==ERROR ) printf(\"Deque is Empty!\\n\");\n            else printf(\"%d is out\\n\", X);\n            break;\n        case inject: \n            scanf(\"%d\", &X);\n            if (!Inject(X, D)) printf(\"Deque is Full!\\n\");\n            break;\n        case eject:\n            X = Eject(D);\n            if ( X==ERROR ) printf(\"Deque is Empty!\\n\");\n            else printf(\"%d is out\\n\", X);\n            break;\n        case end:\n            PrintDeque(D);\n            done = 1;\n            break;\n        }\n    }\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n3\nPop\nInject 1\nPop\nEject\nPush 2\nPush 3\nEject\nInject 4\nInject 5\nInject 6\nPush 7\nPop\nEnd\n```\n\n### 输出样例：\n```out\nDeque is Empty!\n1 is out\nDeque is Empty!\n2 is out\nDeque is Full!\nDeque is Full!\n3 is out\nInside Deque: 4 5\n```"}}
{"problemSetProblem": {"id": "6098", "label": "习题3.14", "score": 15, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "另类堆栈", "content": "在栈的顺序存储实现中，另有一种方法是将Top定义为栈顶的上一个位置。请编写程序实现这种定义下堆栈的入栈、出栈操作。如何判断堆栈为空或者满？\n\n### 函数接口定义：\n```c++\nbool Push( Stack S, ElementType X );\nElementType Pop( Stack S );\n```\n\n其中`Stack`结构定义如下：\n\n```c++\ntypedef int Position;\ntypedef struct SNode *PtrToSNode;\nstruct SNode {\n    ElementType *Data;  /* 存储元素的数组 */\n    Position Top;       /* 栈顶指针       */\n    int MaxSize;        /* 堆栈最大容量   */\n};\ntypedef PtrToSNode Stack;\n```\n注意：如果堆栈已满，`Push`函数必须输出“Stack Full”并且返回false；如果队列是空的，则`Pop`函数必须输出“Stack Empty”，并且返回ERROR。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\ntypedef int ElementType;\ntypedef enum { push, pop, end } Operation;\ntypedef enum { false, true } bool;\ntypedef int Position;\ntypedef struct SNode *PtrToSNode;\nstruct SNode {\n    ElementType *Data;  /* 存储元素的数组 */\n    Position Top;       /* 栈顶指针       */\n    int MaxSize;        /* 堆栈最大容量   */\n};\ntypedef PtrToSNode Stack;\n\nStack CreateStack( int MaxSize )\n{\n    Stack S = (Stack)malloc(sizeof(struct SNode));\n    S->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\n    S->Top = 0;\n    S->MaxSize = MaxSize;\n    return S;\n}\n\nbool Push( Stack S, ElementType X );\nElementType Pop( Stack S );\n\nOperation GetOp();          /* 裁判实现，细节不表 */\nvoid PrintStack( Stack S ); /* 裁判实现，细节不表 */\n\nint main()\n{\n    ElementType X;\n    Stack S;\n    int N, done = 0;\n\n    scanf(\"%d\", &N);\n    S = CreateStack(N);\n    while ( !done ) {\n        switch( GetOp() ) {\n        case push: \n            scanf(\"%d\", &X);\n            Push(S, X);\n            break;\n        case pop:\n            X = Pop(S);\n            if ( X!=ERROR ) printf(\"%d is out\\n\", X);\n            break;\n        case end:\n            PrintStack(S);\n            done = 1;\n            break;\n        }\n    }\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n4\nPop\nPush 5\nPush 4\nPush 3\nPop\nPop\nPush 2\nPush 1\nPush 0\nPush 10\nEnd\n```\n\n### 输出样例：\n```out\nStack Empty\n3 is out\n4 is out\nStack Full\n0 1 2 5 \n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1508", "description": "在栈的顺序存储实现中，另有一种方法是将Top定义为栈顶的上一个位置。请编写程序实现这种定义下堆栈的入栈、出栈操作。如何判断堆栈为空或者满？\n\n### 函数接口定义：\n```c++\nbool Push( Stack S, ElementType X );\nElementType Pop( Stack S );\n```\n\n其中`Stack`结构定义如下：\n\n```c++\ntypedef int Position;\ntypedef struct SNode *PtrToSNode;\nstruct SNode {\n    ElementType *Data;  /* 存储元素的数组 */\n    Position Top;       /* 栈顶指针       */\n    int MaxSize;        /* 堆栈最大容量   */\n};\ntypedef PtrToSNode Stack;\n```\n注意：如果堆栈已满，`Push`函数必须输出“Stack Full”并且返回false；如果队列是空的，则`Pop`函数必须输出“Stack Empty”，并且返回ERROR。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ERROR -1\ntypedef int ElementType;\ntypedef enum { push, pop, end } Operation;\ntypedef enum { false, true } bool;\ntypedef int Position;\ntypedef struct SNode *PtrToSNode;\nstruct SNode {\n    ElementType *Data;  /* 存储元素的数组 */\n    Position Top;       /* 栈顶指针       */\n    int MaxSize;        /* 堆栈最大容量   */\n};\ntypedef PtrToSNode Stack;\n\nStack CreateStack( int MaxSize )\n{\n    Stack S = (Stack)malloc(sizeof(struct SNode));\n    S->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\n    S->Top = 0;\n    S->MaxSize = MaxSize;\n    return S;\n}\n\nbool Push( Stack S, ElementType X );\nElementType Pop( Stack S );\n\nOperation GetOp();          /* 裁判实现，细节不表 */\nvoid PrintStack( Stack S ); /* 裁判实现，细节不表 */\n\nint main()\n{\n    ElementType X;\n    Stack S;\n    int N, done = 0;\n\n    scanf(\"%d\", &N);\n    S = CreateStack(N);\n    while ( !done ) {\n        switch( GetOp() ) {\n        case push: \n            scanf(\"%d\", &X);\n            Push(S, X);\n            break;\n        case pop:\n            X = Pop(S);\n            if ( X!=ERROR ) printf(\"%d is out\\n\", X);\n            break;\n        case end:\n            PrintStack(S);\n            done = 1;\n            break;\n        }\n    }\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：\n```in\n4\nPop\nPush 5\nPush 4\nPush 3\nPop\nPop\nPush 2\nPush 1\nPush 0\nPush 10\nEnd\n```\n\n### 输出样例：\n```out\nStack Empty\n3 is out\n4 is out\nStack Full\n0 1 2 5 \n```"}}
{"problemSetProblem": {"id": "6178", "label": "习题4.3", "score": 25, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "是否二叉搜索树", "content": "本题要求实现函数，判断给定二叉树是否二叉搜索树。\n\n### 函数接口定义：\n```c++\nbool IsBST ( BinTree T );\n```\n\n其中`BinTree`结构定义如下：\n```c++\ntypedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode{\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n};\n```\n函数`IsBST`须判断给定的`T`是否二叉搜索树，即满足如下定义的二叉树：\n\n定义：一个二叉搜索树是一棵二叉树，它可以为空。如果不为空，它将满足以下性质：\n\n- 非空左子树的所有键值小于其根结点的键值。\n- 非空右子树的所有键值大于其根结点的键值。\n- 左、右子树都是二叉搜索树。\n\n如果`T`是二叉搜索树，则函数返回true，否则返回false。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum { false, true } bool;\ntypedef int ElementType;\ntypedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode{\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n};\n\nBinTree BuildTree(); /* 由裁判实现，细节不表 */\nbool IsBST ( BinTree T );\n\nint main()\n{\n    BinTree T;\n\n    T = BuildTree();\n    if ( IsBST(T) ) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n\n    return 0;\n}\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：如下图\n\n![](~/98)\n\n### 输出样例1：\n```out\nYes\n```\n\n### 输入样例2：如下图\n\n![](~/99)\n\n### 输出样例2：\n```\nNo\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1522", "description": "本题要求实现函数，判断给定二叉树是否二叉搜索树。\n\n### 函数接口定义：\n```c++\nbool IsBST ( BinTree T );\n```\n\n其中`BinTree`结构定义如下：\n```c++\ntypedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode{\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n};\n```\n函数`IsBST`须判断给定的`T`是否二叉搜索树，即满足如下定义的二叉树：\n\n定义：一个二叉搜索树是一棵二叉树，它可以为空。如果不为空，它将满足以下性质：\n\n- 非空左子树的所有键值小于其根结点的键值。\n- 非空右子树的所有键值大于其根结点的键值。\n- 左、右子树都是二叉搜索树。\n\n如果`T`是二叉搜索树，则函数返回true，否则返回false。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum { false, true } bool;\ntypedef int ElementType;\ntypedef struct TNode *Position;\ntypedef Position BinTree;\nstruct TNode{\n    ElementType Data;\n    BinTree Left;\n    BinTree Right;\n};\n\nBinTree BuildTree(); /* 由裁判实现，细节不表 */\nbool IsBST ( BinTree T );\n\nint main()\n{\n    BinTree T;\n\n    T = BuildTree();\n    if ( IsBST(T) ) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n\n    return 0;\n}\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：如下图\n\n![](~/98)\n\n### 输出样例1：\n```out\nYes\n```\n\n### 输入样例2：如下图\n\n![](~/99)\n\n### 输出样例2：\n```\nNo\n```"}}
{"problemSetProblem": {"id": "6182", "label": "习题5.10", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "线性探测法的查找函数", "content": "试实现线性探测法的查找函数。\n\n### 函数接口定义：\n```c++\nPosition Find( HashTable H, ElementType Key );\n```\n\n其中`HashTable`是开放地址散列表，定义如下：\n\n```\n#define MAXTABLESIZE 100000  /* 允许开辟的最大散列表长度 */\ntypedef int ElementType;     /* 关键词类型用整型 */\ntypedef int Index;           /* 散列地址类型 */\ntypedef Index Position;      /* 数据所在位置与散列地址是同一类型 */\n/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */\ntypedef enum { Legitimate, Empty, Deleted } EntryType;\n\ntypedef struct HashEntry Cell; /* 散列表单元类型 */\nstruct HashEntry{\n    ElementType Data; /* 存放元素 */\n    EntryType Info;   /* 单元状态 */\n};\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    Cell *Cells;   /* 存放散列单元数据的数组 */\n};\n```\n函数`Find`应根据裁判定义的散列函数`Hash( Key, H->TableSize )`从散列表`H`中查到`Key`的位置并返回。如果`Key`不存在，则返回线性探测法找到的第一个空单元的位置；若没有空单元，则返回`ERROR`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\n#define MAXTABLESIZE 100000  /* 允许开辟的最大散列表长度 */\ntypedef int ElementType;     /* 关键词类型用整型 */\ntypedef int Index;           /* 散列地址类型 */\ntypedef Index Position;      /* 数据所在位置与散列地址是同一类型 */\n/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */\ntypedef enum { Legitimate, Empty, Deleted } EntryType;\n\ntypedef struct HashEntry Cell; /* 散列表单元类型 */\nstruct HashEntry{\n    ElementType Data; /* 存放元素 */\n    EntryType Info;   /* 单元状态 */\n};\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    Cell *Cells;   /* 存放散列单元数据的数组 */\n};\n\nHashTable BuildTable(); /* 裁判实现，细节不表 */\nPosition Hash( ElementType Key, int TableSize )\n{\n    return (Key % TableSize);\n}\n\n#define ERROR -1\nPosition Find( HashTable H, ElementType Key );\n\nint main()\n{\n    HashTable H;\n    ElementType Key;\n    Position P;\n\n    H = BuildTable(); \n    scanf(\"%d\", &Key);\n    P = Find(H, Key);\n    if (P==ERROR)\n        printf(\"ERROR: %d is not found and the table is full.\\n\", Key);\n    else if (H->Cells[P].Info == Legitimate)\n        printf(\"%d is at position %d.\\n\", Key, P);\n    else\n        printf(\"%d is not found.  Position %d is returned.\\n\", Key, P);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：（注：-1表示该位置为空。下同。）\n```in\n11\n11 88 21 -1 -1 5 16 7 6 38 10\n38\n```\n\n### 输出样例1：\n```out\n38 is at position 9.\n```\n\n### 输入样例2：\n```\n11\n11 88 21 -1 -1 5 16 7 6 38 10\n41\n```\n\n### 输出样例2：\n```\n41 is not found.  Position 3 is returned.\n```\n\n### 输入样例3：\n```\n11\n11 88 21 3 14 5 16 7 6 38 10\n41\n```\n\n### 输出样例3：\n```\nERROR: 41 is not found and the table is full.\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1524", "description": "试实现线性探测法的查找函数。\n\n### 函数接口定义：\n```c++\nPosition Find( HashTable H, ElementType Key );\n```\n\n其中`HashTable`是开放地址散列表，定义如下：\n\n```\n#define MAXTABLESIZE 100000  /* 允许开辟的最大散列表长度 */\ntypedef int ElementType;     /* 关键词类型用整型 */\ntypedef int Index;           /* 散列地址类型 */\ntypedef Index Position;      /* 数据所在位置与散列地址是同一类型 */\n/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */\ntypedef enum { Legitimate, Empty, Deleted } EntryType;\n\ntypedef struct HashEntry Cell; /* 散列表单元类型 */\nstruct HashEntry{\n    ElementType Data; /* 存放元素 */\n    EntryType Info;   /* 单元状态 */\n};\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    Cell *Cells;   /* 存放散列单元数据的数组 */\n};\n```\n函数`Find`应根据裁判定义的散列函数`Hash( Key, H->TableSize )`从散列表`H`中查到`Key`的位置并返回。如果`Key`不存在，则返回线性探测法找到的第一个空单元的位置；若没有空单元，则返回`ERROR`。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\n#define MAXTABLESIZE 100000  /* 允许开辟的最大散列表长度 */\ntypedef int ElementType;     /* 关键词类型用整型 */\ntypedef int Index;           /* 散列地址类型 */\ntypedef Index Position;      /* 数据所在位置与散列地址是同一类型 */\n/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */\ntypedef enum { Legitimate, Empty, Deleted } EntryType;\n\ntypedef struct HashEntry Cell; /* 散列表单元类型 */\nstruct HashEntry{\n    ElementType Data; /* 存放元素 */\n    EntryType Info;   /* 单元状态 */\n};\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    Cell *Cells;   /* 存放散列单元数据的数组 */\n};\n\nHashTable BuildTable(); /* 裁判实现，细节不表 */\nPosition Hash( ElementType Key, int TableSize )\n{\n    return (Key % TableSize);\n}\n\n#define ERROR -1\nPosition Find( HashTable H, ElementType Key );\n\nint main()\n{\n    HashTable H;\n    ElementType Key;\n    Position P;\n\n    H = BuildTable(); \n    scanf(\"%d\", &Key);\n    P = Find(H, Key);\n    if (P==ERROR)\n        printf(\"ERROR: %d is not found and the table is full.\\n\", Key);\n    else if (H->Cells[P].Info == Legitimate)\n        printf(\"%d is at position %d.\\n\", Key, P);\n    else\n        printf(\"%d is not found.  Position %d is returned.\\n\", Key, P);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：（注：-1表示该位置为空。下同。）\n```in\n11\n11 88 21 -1 -1 5 16 7 6 38 10\n38\n```\n\n### 输出样例1：\n```out\n38 is at position 9.\n```\n\n### 输入样例2：\n```\n11\n11 88 21 -1 -1 5 16 7 6 38 10\n41\n```\n\n### 输出样例2：\n```\n41 is not found.  Position 3 is returned.\n```\n\n### 输入样例3：\n```\n11\n11 88 21 3 14 5 16 7 6 38 10\n41\n```\n\n### 输出样例3：\n```\nERROR: 41 is not found and the table is full.\n```"}}
{"problemSetProblem": {"id": "6222", "label": "习题5.11", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "分离链接法的删除操作函数", "content": "试实现分离链接法的删除操作函数。\n\n### 函数接口定义：\n```c++\nbool Delete( HashTable H, ElementType Key );\n```\n\n其中`HashTable`是分离链接散列表，定义如下：\n\n```\ntypedef struct LNode *PtrToLNode;\nstruct LNode {\n    ElementType Data;\n    PtrToLNode Next;\n};\ntypedef PtrToLNode Position;\ntypedef PtrToLNode List;\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    List Heads;    /* 指向链表头结点的数组 */\n};\n```\n函数`Delete`应根据裁判定义的散列函数`Hash( Key, H->TableSize )`从散列表`H`中查到`Key`的位置并删除之，然后输出一行文字：`Key is deleted from list Heads[i]`，其中`Key`是传入的被删除的关键词，`i`是`Key`所在的链表的编号；最后返回true。如果`Key`不存在，则返回false。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <string.h>\n\n#define KEYLENGTH 15                   /* 关键词字符串的最大长度 */\ntypedef char ElementType[KEYLENGTH+1]; /* 关键词类型用字符串 */\ntypedef int Index;                     /* 散列地址类型 */\ntypedef enum {false, true} bool;\n\ntypedef struct LNode *PtrToLNode;\nstruct LNode {\n    ElementType Data;\n    PtrToLNode Next;\n};\ntypedef PtrToLNode Position;\ntypedef PtrToLNode List;\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    List Heads;    /* 指向链表头结点的数组 */\n};\n\nIndex Hash( ElementType Key, int TableSize )\n{\n    return (Key[0]-'a')%TableSize;\n}\n\nHashTable BuildTable(); /* 裁判实现，细节不表 */\nbool Delete( HashTable H, ElementType Key );\n\nint main()\n{\n    HashTable H;\n    ElementType Key;\n\n    H = BuildTable(); \n    scanf(\"%s\", Key);\n    if (Delete(H, Key) == false)\n        printf(\"ERROR: %s is not found\\n\", Key);\n    if (Delete(H, Key) == true)\n        printf(\"Are you kidding me?\\n\");\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：散列表如下图\n\n![](~/100)\n```\nable\n```\n\n### 输出样例1：\n```out\nable is deleted from list Heads[0]\n```\n\n### 输入样例2：散列表如样例1图\n```in\ndate\n```\n\n### 输出样例2：\n```\nERROR: date is not found\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1525", "description": "试实现分离链接法的删除操作函数。\n\n### 函数接口定义：\n```c++\nbool Delete( HashTable H, ElementType Key );\n```\n\n其中`HashTable`是分离链接散列表，定义如下：\n\n```\ntypedef struct LNode *PtrToLNode;\nstruct LNode {\n    ElementType Data;\n    PtrToLNode Next;\n};\ntypedef PtrToLNode Position;\ntypedef PtrToLNode List;\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    List Heads;    /* 指向链表头结点的数组 */\n};\n```\n函数`Delete`应根据裁判定义的散列函数`Hash( Key, H->TableSize )`从散列表`H`中查到`Key`的位置并删除之，然后输出一行文字：`Key is deleted from list Heads[i]`，其中`Key`是传入的被删除的关键词，`i`是`Key`所在的链表的编号；最后返回true。如果`Key`不存在，则返回false。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n#include <string.h>\n\n#define KEYLENGTH 15                   /* 关键词字符串的最大长度 */\ntypedef char ElementType[KEYLENGTH+1]; /* 关键词类型用字符串 */\ntypedef int Index;                     /* 散列地址类型 */\ntypedef enum {false, true} bool;\n\ntypedef struct LNode *PtrToLNode;\nstruct LNode {\n    ElementType Data;\n    PtrToLNode Next;\n};\ntypedef PtrToLNode Position;\ntypedef PtrToLNode List;\n\ntypedef struct TblNode *HashTable; /* 散列表类型 */\nstruct TblNode {   /* 散列表结点定义 */\n    int TableSize; /* 表的最大长度 */\n    List Heads;    /* 指向链表头结点的数组 */\n};\n\nIndex Hash( ElementType Key, int TableSize )\n{\n    return (Key[0]-'a')%TableSize;\n}\n\nHashTable BuildTable(); /* 裁判实现，细节不表 */\nbool Delete( HashTable H, ElementType Key );\n\nint main()\n{\n    HashTable H;\n    ElementType Key;\n\n    H = BuildTable(); \n    scanf(\"%s\", Key);\n    if (Delete(H, Key) == false)\n        printf(\"ERROR: %s is not found\\n\", Key);\n    if (Delete(H, Key) == true)\n        printf(\"Are you kidding me?\\n\");\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例1：散列表如下图\n\n![](~/100)\n```\nable\n```\n\n### 输出样例1：\n```out\nable is deleted from list Heads[0]\n```\n\n### 输入样例2：散列表如样例1图\n```in\ndate\n```\n\n### 输出样例2：\n```\nERROR: date is not found\n```"}}
{"problemSetProblem": {"id": "6472", "label": "练习6.1", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "邻接矩阵存储图的深度优先遍历", "content": "试实现邻接矩阵存储图的深度优先遍历。\n\n### 函数接口定义：\n```c++\nvoid DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );\n```\n\n其中`MGraph`是邻接矩阵存储的图，定义如下：\n\n```\ntypedef struct GNode *PtrToGNode;\nstruct GNode{\n    int Nv;  /* 顶点数 */\n    int Ne;  /* 边数   */\n    WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */\n};\ntypedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */\n```\n函数`DFS`应从第`V`个顶点出发递归地深度优先遍历图`Graph`，遍历时用裁判定义的函数`Visit`访问每个顶点。当访问邻接点时，要求按序号递增的顺序。题目保证`V`是图中的合法顶点。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\ntypedef enum {false, true} bool;\n#define MaxVertexNum 10  /* 最大顶点数设为10 */\n#define INFINITY 65535   /* ∞设为双字节无符号整数的最大值65535*/\ntypedef int Vertex;      /* 用顶点下标表示顶点,为整型 */\ntypedef int WeightType;  /* 边的权值设为整型 */\n\ntypedef struct GNode *PtrToGNode;\nstruct GNode{\n    int Nv;  /* 顶点数 */\n    int Ne;  /* 边数   */\n    WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */\n};\ntypedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */\nbool Visited[MaxVertexNum]; /* 顶点的访问标记 */\n\nMGraph CreateGraph(); /* 创建图并且将Visited初始化为false；裁判实现，细节不表 */\n\nvoid Visit( Vertex V )\n{\n    printf(\" %d\", V);\n}\n\nvoid DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );\n\n\nint main()\n{\n    MGraph G;\n    Vertex V;\n\n    G = CreateGraph();\n    scanf(\"%d\", &V);\n    printf(\"DFS from %d:\", V);\n    DFS(G, V, Visit);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：给定图如下\n\n![](~/101)\n```\n5\n```\n\n### 输出样例：\n```out\nDFS from 5: 5 1 3 0 2 4 6\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1528", "description": "试实现邻接矩阵存储图的深度优先遍历。\n\n### 函数接口定义：\n```c++\nvoid DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );\n```\n\n其中`MGraph`是邻接矩阵存储的图，定义如下：\n\n```\ntypedef struct GNode *PtrToGNode;\nstruct GNode{\n    int Nv;  /* 顶点数 */\n    int Ne;  /* 边数   */\n    WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */\n};\ntypedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */\n```\n函数`DFS`应从第`V`个顶点出发递归地深度优先遍历图`Graph`，遍历时用裁判定义的函数`Visit`访问每个顶点。当访问邻接点时，要求按序号递增的顺序。题目保证`V`是图中的合法顶点。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\ntypedef enum {false, true} bool;\n#define MaxVertexNum 10  /* 最大顶点数设为10 */\n#define INFINITY 65535   /* ∞设为双字节无符号整数的最大值65535*/\ntypedef int Vertex;      /* 用顶点下标表示顶点,为整型 */\ntypedef int WeightType;  /* 边的权值设为整型 */\n\ntypedef struct GNode *PtrToGNode;\nstruct GNode{\n    int Nv;  /* 顶点数 */\n    int Ne;  /* 边数   */\n    WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */\n};\ntypedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */\nbool Visited[MaxVertexNum]; /* 顶点的访问标记 */\n\nMGraph CreateGraph(); /* 创建图并且将Visited初始化为false；裁判实现，细节不表 */\n\nvoid Visit( Vertex V )\n{\n    printf(\" %d\", V);\n}\n\nvoid DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) );\n\n\nint main()\n{\n    MGraph G;\n    Vertex V;\n\n    G = CreateGraph();\n    scanf(\"%d\", &V);\n    printf(\"DFS from %d:\", V);\n    DFS(G, V, Visit);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：给定图如下\n\n![](~/101)\n```\n5\n```\n\n### 输出样例：\n```out\nDFS from 5: 5 1 3 0 2 4 6\n```"}}
{"problemSetProblem": {"id": "6475", "label": "练习6.2", "score": 20, "problemConfig": {"codeCompletionProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": ""}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "邻接表存储图的广度优先遍历", "content": "试实现邻接表存储图的广度优先遍历。\n\n### 函数接口定义：\n```c++\nvoid BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) );\n```\n\n其中`LGraph`是邻接表存储的图，定义如下：\n\n```\n/* 邻接点的定义 */\ntypedef struct AdjVNode *PtrToAdjVNode; \nstruct AdjVNode{\n    Vertex AdjV;        /* 邻接点下标 */\n    PtrToAdjVNode Next; /* 指向下一个邻接点的指针 */\n};\n\n/* 顶点表头结点的定义 */\ntypedef struct Vnode{\n    PtrToAdjVNode FirstEdge; /* 边表头指针 */\n} AdjList[MaxVertexNum];     /* AdjList是邻接表类型 */\n\n/* 图结点的定义 */\ntypedef struct GNode *PtrToGNode;\nstruct GNode{  \n    int Nv;     /* 顶点数 */\n    int Ne;     /* 边数   */\n    AdjList G;  /* 邻接表 */\n};\ntypedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */\n```\n函数`BFS`应从第`S`个顶点出发对邻接表存储的图`Graph`进行广度优先搜索，遍历时用裁判定义的函数`Visit`访问每个顶点。当访问邻接点时，要求按邻接表顺序访问。题目保证`S`是图中的合法顶点。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\ntypedef enum {false, true} bool;\n#define MaxVertexNum 10   /* 最大顶点数设为10 */\ntypedef int Vertex;       /* 用顶点下标表示顶点,为整型 */\n\n/* 邻接点的定义 */\ntypedef struct AdjVNode *PtrToAdjVNode; \nstruct AdjVNode{\n    Vertex AdjV;        /* 邻接点下标 */\n    PtrToAdjVNode Next; /* 指向下一个邻接点的指针 */\n};\n\n/* 顶点表头结点的定义 */\ntypedef struct Vnode{\n    PtrToAdjVNode FirstEdge; /* 边表头指针 */\n} AdjList[MaxVertexNum];     /* AdjList是邻接表类型 */\n\n/* 图结点的定义 */\ntypedef struct GNode *PtrToGNode;\nstruct GNode{  \n    int Nv;     /* 顶点数 */\n    int Ne;     /* 边数   */\n    AdjList G;  /* 邻接表 */\n};\ntypedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */\n\nbool Visited[MaxVertexNum]; /* 顶点的访问标记 */\n\nLGraph CreateGraph(); /* 创建图并且将Visited初始化为false；裁判实现，细节不表 */\n\nvoid Visit( Vertex V )\n{\n    printf(\" %d\", V);\n}\n\nvoid BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) );\n\nint main()\n{\n    LGraph G;\n    Vertex S;\n\n    G = CreateGraph();\n    scanf(\"%d\", &S);\n    printf(\"BFS from %d:\", S);\n    BFS(G, S, Visit);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：给定图如下\n\n![](~/102)\n```\n2\n```\n\n### 输出样例：\n```out\nBFS from 2: 2 0 3 5 4 1 6\n```", "type": "CODE_COMPLETION", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "GCC", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1529", "description": "试实现邻接表存储图的广度优先遍历。\n\n### 函数接口定义：\n```c++\nvoid BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) );\n```\n\n其中`LGraph`是邻接表存储的图，定义如下：\n\n```\n/* 邻接点的定义 */\ntypedef struct AdjVNode *PtrToAdjVNode; \nstruct AdjVNode{\n    Vertex AdjV;        /* 邻接点下标 */\n    PtrToAdjVNode Next; /* 指向下一个邻接点的指针 */\n};\n\n/* 顶点表头结点的定义 */\ntypedef struct Vnode{\n    PtrToAdjVNode FirstEdge; /* 边表头指针 */\n} AdjList[MaxVertexNum];     /* AdjList是邻接表类型 */\n\n/* 图结点的定义 */\ntypedef struct GNode *PtrToGNode;\nstruct GNode{  \n    int Nv;     /* 顶点数 */\n    int Ne;     /* 边数   */\n    AdjList G;  /* 邻接表 */\n};\ntypedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */\n```\n函数`BFS`应从第`S`个顶点出发对邻接表存储的图`Graph`进行广度优先搜索，遍历时用裁判定义的函数`Visit`访问每个顶点。当访问邻接点时，要求按邻接表顺序访问。题目保证`S`是图中的合法顶点。\n\n### 裁判测试程序样例：\n```c++\n#include <stdio.h>\n\ntypedef enum {false, true} bool;\n#define MaxVertexNum 10   /* 最大顶点数设为10 */\ntypedef int Vertex;       /* 用顶点下标表示顶点,为整型 */\n\n/* 邻接点的定义 */\ntypedef struct AdjVNode *PtrToAdjVNode; \nstruct AdjVNode{\n    Vertex AdjV;        /* 邻接点下标 */\n    PtrToAdjVNode Next; /* 指向下一个邻接点的指针 */\n};\n\n/* 顶点表头结点的定义 */\ntypedef struct Vnode{\n    PtrToAdjVNode FirstEdge; /* 边表头指针 */\n} AdjList[MaxVertexNum];     /* AdjList是邻接表类型 */\n\n/* 图结点的定义 */\ntypedef struct GNode *PtrToGNode;\nstruct GNode{  \n    int Nv;     /* 顶点数 */\n    int Ne;     /* 边数   */\n    AdjList G;  /* 邻接表 */\n};\ntypedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */\n\nbool Visited[MaxVertexNum]; /* 顶点的访问标记 */\n\nLGraph CreateGraph(); /* 创建图并且将Visited初始化为false；裁判实现，细节不表 */\n\nvoid Visit( Vertex V )\n{\n    printf(\" %d\", V);\n}\n\nvoid BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) );\n\nint main()\n{\n    LGraph G;\n    Vertex S;\n\n    G = CreateGraph();\n    scanf(\"%d\", &S);\n    printf(\"BFS from %d:\", S);\n    BFS(G, S, Visit);\n\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n```\n\n### 输入样例：给定图如下\n\n![](~/102)\n```\n2\n```\n\n### 输出样例：\n```out\nBFS from 2: 2 0 3 5 4 1 6\n```"}}
