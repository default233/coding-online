{"problemSetProblem": {"id": "5404", "label": "实例1.1", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 50000, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "最大子列和问题", "content": "给定$$K$$个整数组成的序列{ $$N_1$$, $$N_2$$, ..., $$N_K$$ }，“连续子列”被定义为{ $$N_i$$, $$N_{i+1}$$, ..., $$N_j$$ }，其中 $$1 \\le i \\le j \\le K$$。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 \n\n本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：\n\n- 数据1：与样例等价，测试基本正确性；\n- 数据2：10<sup>2</sup>个随机整数；\n- 数据3：10<sup>3</sup>个随机整数；\n- 数据4：10<sup>4</sup>个随机整数；\n- 数据5：10<sup>5</sup>个随机整数；\n\n### 输入格式:\n\n输入第1行给出正整数$$K$$ ($$\\le 100000$$)；第2行给出$$K$$个整数，其间以空格分隔。 \n\n### 输出格式:\n\n在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 \n\n### 输入样例:\n```in\n6\n-2 11 -4 13 -5 -2\n```\n\n### 输出样例:\n```out\n20\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "300", "description": "给定$$K$$个整数组成的序列{ $$N_1$$, $$N_2$$, ..., $$N_K$$ }，“连续子列”被定义为{ $$N_i$$, $$N_{i+1}$$, ..., $$N_j$$ }，其中 $$1 \\le i \\le j \\le K$$。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 \n\n本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：\n\n- 数据1：与样例等价，测试基本正确性；\n- 数据2：10<sup>2</sup>个随机整数；\n- 数据3：10<sup>3</sup>个随机整数；\n- 数据4：10<sup>4</sup>个随机整数；\n- 数据5：10<sup>5</sup>个随机整数；\n\n### 输入格式:\n\n输入第1行给出正整数$$K$$ ($$\\le 100000$$)；第2行给出$$K$$个整数，其间以空格分隔。 \n\n### 输出格式:\n\n在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 \n\n### 输入样例:\n```in\n6\n-2 11 -4 13 -5 -2\n```\n\n### 输出样例:\n```out\n20\n```"}}
{"problemSetProblem": {"id": "5405", "label": "习题2.1", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "简单计算器", "content": "模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，四种运算符的优先级相同，按从左到右的顺序计算。\n\n### 输入格式:\n\n输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。\n\n### 输出格式:\n\n在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。\n\n### 输入样例:\n```in\n1+2*10-10/2=\n```\n\n### 输出样例:\n```out\n10\n```", "type": "PROGRAMMING", "author": "张彤彧", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "420", "description": "模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，四种运算符的优先级相同，按从左到右的顺序计算。\n\n### 输入格式:\n\n输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。\n\n### 输出格式:\n\n在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。\n\n### 输入样例:\n```in\n1+2*10-10/2=\n```\n\n### 输出样例:\n```out\n10\n```"}}
{"problemSetProblem": {"id": "5653", "label": "习题2.2", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "数组循环左移", "content": "本题要求实现一个对数组进行循环左移的简单函数：一个数组$$a$$中存有$$n$$（$$>0$$）个整数，在不允许使用另外数组的前提下，将每个整数循环向左移$$m$$（$$\\ge 0$$）个位置，即将$$a$$中的数据由（$$a_0 a_1 \\cdots a_{n-1}$$）变换为（$$a_{m} \\cdots a_{n-1} a_0 a_1 \\cdots a_{m-1}$$）（最前面的$$m$$个数循环移至最后面的$$m$$个位置）。如果还需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n\n### 输入格式:\n\n输入第1行给出正整数$$n$$（$$\\le 100$$）和整数$$m$$（$$\\ge 0$$）；第2行给出$$n$$个整数，其间以空格分隔。 \n\n### 输出格式:\n\n在一行中输出循环左移$$m$$位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n\n### 输入样例：\n```in\n8 3\n1 2 3 4 5 6 7 8\n```\n\n### 输出样例：\n```out\n4 5 6 7 8 1 2 3\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1387", "description": "本题要求实现一个对数组进行循环左移的简单函数：一个数组$$a$$中存有$$n$$（$$>0$$）个整数，在不允许使用另外数组的前提下，将每个整数循环向左移$$m$$（$$\\ge 0$$）个位置，即将$$a$$中的数据由（$$a_0 a_1 \\cdots a_{n-1}$$）变换为（$$a_{m} \\cdots a_{n-1} a_0 a_1 \\cdots a_{m-1}$$）（最前面的$$m$$个数循环移至最后面的$$m$$个位置）。如果还需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？\n\n### 输入格式:\n\n输入第1行给出正整数$$n$$（$$\\le 100$$）和整数$$m$$（$$\\ge 0$$）；第2行给出$$n$$个整数，其间以空格分隔。 \n\n### 输出格式:\n\n在一行中输出循环左移$$m$$位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n\n### 输入样例：\n```in\n8 3\n1 2 3 4 5 6 7 8\n```\n\n### 输出样例：\n```out\n4 5 6 7 8 1 2 3\n```"}}
{"problemSetProblem": {"id": "5654", "label": "习题2.3", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 200, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "数列求和-加强版", "content": "给定某数字$$A$$（$$1\\le A\\le 9$$）以及非负整数$$N$$（$$0\\le N\\le 100000$$），求数列之和$$S = A + AA + AAA + \\cdots + AA\\cdots A$$（$$N$$个$$A$$）。例如$$A=1$$, $$N=3$$时，$$S = 1 + 11 + 111 = 123$$。\n\n### 输入格式：\n\n输入数字$$A$$与非负整数$$N$$。\n\n### 输出格式：\n\n输出其$$N$$项数列之和$$S$$的值。\n\n### 输入样例：\n```in\n1 3\n```\n\n### 输出样例：\n```out\n123\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1130", "description": "给定某数字$$A$$（$$1\\le A\\le 9$$）以及非负整数$$N$$（$$0\\le N\\le 100000$$），求数列之和$$S = A + AA + AAA + \\cdots + AA\\cdots A$$（$$N$$个$$A$$）。例如$$A=1$$, $$N=3$$时，$$S = 1 + 11 + 111 = 123$$。\n\n### 输入格式：\n\n输入数字$$A$$与非负整数$$N$$。\n\n### 输出格式：\n\n输出其$$N$$项数列之和$$S$$的值。\n\n### 输入样例：\n```in\n1 3\n```\n\n### 输出样例：\n```out\n123\n```"}}
{"problemSetProblem": {"id": "5811", "label": "习题2.8", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 3500, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "输出全排列", "content": "请编写程序输出前$$n$$个正整数的全排列（$$n<10$$），并通过9个测试用例（即$$n$$从1到9）观察$$n$$逐步增大时程序的运行时间。\n\n### 输入格式:\n\n输入给出正整数$$n$$（$$<10$$）。 \n\n### 输出格式:\n\n输出1到$$n$$的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列$${ a_1, a_2, \\cdots, a_n }$$排在序列$${ b_1, b_2, \\cdots, b_n }$$之前，如果存在$$k$$使得$$a_1=b_1, \\cdots, a_k=b_k$$ 并且 $$a_{k+1}<b_{k+1}$$。\n\n### 输入样例：\n```in\n3\n```\n\n### 输出样例：\n```out\n123\n132\n213\n231\n312\n321\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1442", "description": "请编写程序输出前$$n$$个正整数的全排列（$$n<10$$），并通过9个测试用例（即$$n$$从1到9）观察$$n$$逐步增大时程序的运行时间。\n\n### 输入格式:\n\n输入给出正整数$$n$$（$$<10$$）。 \n\n### 输出格式:\n\n输出1到$$n$$的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列$${ a_1, a_2, \\cdots, a_n }$$排在序列$${ b_1, b_2, \\cdots, b_n }$$之前，如果存在$$k$$使得$$a_1=b_1, \\cdots, a_k=b_k$$ 并且 $$a_{k+1}<b_{k+1}$$。\n\n### 输入样例：\n```in\n3\n```\n\n### 输出样例：\n```out\n123\n132\n213\n231\n312\n321\n```"}}
{"problemSetProblem": {"id": "5860", "label": "习题3.4", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "最长连续递增子序列", "content": "给定一个顺序存储的线性表，请设计一个算法查找该线性表中最长的连续递增子序列。例如，(1,9,2,5,7,3,4,6,8,0)中最长的递增子序列为(3,4,6,8)。\n\n### 输入格式:\n\n输入第1行给出正整数$$n$$（$$\\le 10^5$$）；第2行给出$$n$$个整数，其间以空格分隔。 \n\n### 输出格式:\n\n在一行中输出第一次出现的最长连续递增子序列，数字之间用空格分隔，序列结尾不能有多余空格。\n\n### 输入样例：\n```in\n15\n1 9 2 5 7 3 4 6 8 0 11 15 17 17 10\n```\n\n### 输出样例：\n```out\n3 4 6 8\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1492", "description": "给定一个顺序存储的线性表，请设计一个算法查找该线性表中最长的连续递增子序列。例如，(1,9,2,5,7,3,4,6,8,0)中最长的递增子序列为(3,4,6,8)。\n\n### 输入格式:\n\n输入第1行给出正整数$$n$$（$$\\le 10^5$$）；第2行给出$$n$$个整数，其间以空格分隔。 \n\n### 输出格式:\n\n在一行中输出第一次出现的最长连续递增子序列，数字之间用空格分隔，序列结尾不能有多余空格。\n\n### 输入样例：\n```in\n15\n1 9 2 5 7 3 4 6 8 0 11 15 17 17 10\n```\n\n### 输出样例：\n```out\n3 4 6 8\n```"}}
{"problemSetProblem": {"id": "5865", "label": "习题3.6", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 200, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "一元多项式的乘法与加法运算", "content": "设计函数分别求两个一元多项式的乘积与和。\n\n### 输入格式:\n\n输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。\n\n### 输出格式:\n\n输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出`0 0`。\n\n### 输入样例:\n```in\n4 3 4 -5 2  6 1  -2 0\n3 5 20  -7 4  3 1\n```\n\n### 输出样例:\n```out\n15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1\n5 20 -4 4 -5 2 9 1 -2 0\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "302", "description": "设计函数分别求两个一元多项式的乘积与和。\n\n### 输入格式:\n\n输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。\n\n### 输出格式:\n\n输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出`0 0`。\n\n### 输入样例:\n```in\n4 3 4 -5 2  6 1  -2 0\n3 5 20  -7 4  3 1\n```\n\n### 输出样例:\n```out\n15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1\n5 20 -4 4 -5 2 9 1 -2 0\n```"}}
{"problemSetProblem": {"id": "5869", "label": "习题3.8", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "符号配对", "content": "请编写程序检查C语言源程序中下列符号是否配对：`/*`与`*/`、`(`与`)`、`[`与`]`、`{`与`}`。\n\n### 输入格式:\n\n输入为一个C语言源程序。当读到某一行中只有一个句点`.`和一个回车的时候，标志着输入结束。程序中需要检查配对的符号不超过100个。\n\n### 输出格式:\n\n首先，如果所有符号配对正确，则在第一行中输出`YES`，否则输出`NO`。然后在第二行中指出第一个不配对的符号：如果缺少左符号，则输出`?-右符号`；如果缺少右符号，则输出`左符号-?`。\n\n### 输入样例1：\n```in\nvoid test()\n{\n    int i, A[10];\n    for (i=0; i<10; i++) /*/\n        A[i] = i;\n}\n.\n\n```\n\n### 输出样例1：\n```out\nNO\n/*-?\n```\n\n### 输入样例2：\n```\nvoid test()\n{\n    int i, A[10];\n    for (i=0; i<10; i++) /**/\n        A[i] = i;\n}]\n.\n\n```\n\n### 输出样例2：\n```\nNO\n?-]\n```\n\n### 输入样例3：\n```\nvoid test()\n{\n    int i\n    double A[10];\n    for (i=0; i<10; i++) /**/\n        A[i] = 0.1*i;\n}\n.\n\n```\n\n### 输出样例3：\n```\nYES\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1495", "description": "请编写程序检查C语言源程序中下列符号是否配对：`/*`与`*/`、`(`与`)`、`[`与`]`、`{`与`}`。\n\n### 输入格式:\n\n输入为一个C语言源程序。当读到某一行中只有一个句点`.`和一个回车的时候，标志着输入结束。程序中需要检查配对的符号不超过100个。\n\n### 输出格式:\n\n首先，如果所有符号配对正确，则在第一行中输出`YES`，否则输出`NO`。然后在第二行中指出第一个不配对的符号：如果缺少左符号，则输出`?-右符号`；如果缺少右符号，则输出`左符号-?`。\n\n### 输入样例1：\n```in\nvoid test()\n{\n    int i, A[10];\n    for (i=0; i<10; i++) /*/\n        A[i] = i;\n}\n.\n\n```\n\n### 输出样例1：\n```out\nNO\n/*-?\n```\n\n### 输入样例2：\n```\nvoid test()\n{\n    int i, A[10];\n    for (i=0; i<10; i++) /**/\n        A[i] = i;\n}]\n.\n\n```\n\n### 输出样例2：\n```\nNO\n?-]\n```\n\n### 输入样例3：\n```\nvoid test()\n{\n    int i\n    double A[10];\n    for (i=0; i<10; i++) /**/\n        A[i] = 0.1*i;\n}\n.\n\n```\n\n### 输出样例3：\n```\nYES\n```"}}
{"problemSetProblem": {"id": "5891", "label": "习题3.9", "score": 20, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "堆栈操作合法性", "content": "假设以`S`和`X`分别表示入栈和出栈操作。如果根据一个仅由`S`和`X`构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入`S`和`X`序列，判断该序列是否合法。\n\n### 输入格式:\n\n输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（$$\\le 50$$）是堆栈的最大容量。随后N行，每行中给出一个仅由`S`和`X`构成的序列。序列保证不为空，且长度不超过100。\n\n### 输出格式:\n\n对每个序列，在一行中输出`YES`如果该序列是合法的堆栈操作序列，或`NO`如果不是。\n\n### 输入样例：\n```in\n4 10\nSSSXXSXXSX\nSSSXXSXXS\nSSSSSSSSSSXSSXXXXXXXXXXX\nSSSXXSXXX\n```\n\n### 输出样例：\n```out\nYES\nNO\nNO\nNO\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1496", "description": "假设以`S`和`X`分别表示入栈和出栈操作。如果根据一个仅由`S`和`X`构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入`S`和`X`序列，判断该序列是否合法。\n\n### 输入格式:\n\n输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（$$\\le 50$$）是堆栈的最大容量。随后N行，每行中给出一个仅由`S`和`X`构成的序列。序列保证不为空，且长度不超过100。\n\n### 输出格式:\n\n对每个序列，在一行中输出`YES`如果该序列是合法的堆栈操作序列，或`NO`如果不是。\n\n### 输入样例：\n```in\n4 10\nSSSXXSXXSX\nSSSXXSXXS\nSSSSSSSSSSXSSXXXXXXXXXXX\nSSSXXSXXX\n```\n\n### 输出样例：\n```out\nYES\nNO\nNO\nNO\n```"}}
{"problemSetProblem": {"id": "5892", "label": "习题3.10", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "汉诺塔的非递归实现", "content": "借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。\n\n### 输入格式:\n\n输入为一个正整数N，即起始柱上的盘数。\n\n### 输出格式:\n\n每个操作（移动）占一行，按`柱1 -> 柱2`的格式输出。\n\n### 输入样例:\n```in\n3\n```\n\n### 输出样例:\n```out\na -> c\na -> b\nc -> b\na -> c\nb -> a\nb -> c\na -> c\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "604", "description": "借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。\n\n### 输入格式:\n\n输入为一个正整数N，即起始柱上的盘数。\n\n### 输出格式:\n\n每个操作（移动）占一行，按`柱1 -> 柱2`的格式输出。\n\n### 输入样例:\n```in\n3\n```\n\n### 输出样例:\n```out\na -> c\na -> b\nc -> b\na -> c\nb -> a\nb -> c\na -> c\n```"}}
{"problemSetProblem": {"id": "5893", "label": "习题3.11", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "表达式转换", "content": "算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。\n\n### 输入格式:\n\n输入在一行中给出不含空格的中缀表达式，可包含`+`、`-`、`*`、`\\`以及左右括号`()`，表达式不超过20个字符。\n\n### 输出格式:\n\n在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。\n\n### 输入样例:\n```in\n2+3*(7-4)+8/4\n```\n\n### 输出样例:\n```out\n2 3 7 4 - * + 8 4 / +\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "607", "description": "算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。\n\n### 输入格式:\n\n输入在一行中给出不含空格的中缀表达式，可包含`+`、`-`、`*`、`\\`以及左右括号`()`，表达式不超过20个字符。\n\n### 输出格式:\n\n在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。\n\n### 输入样例:\n```in\n2+3*(7-4)+8/4\n```\n\n### 输出样例:\n```out\n2 3 7 4 - * + 8 4 / +\n```"}}
{"problemSetProblem": {"id": "6101", "label": "练习4.1", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "根据后序和中序遍历输出先序遍历", "content": "本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。\n\n### 输入格式:\n\n第一行给出正整数$$N$$($$\\le 30$$)，是树中结点的个数。随后两行，每行给出$$N$$个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。\n\n### 输出格式:\n\n在一行中输出`Preorder: `以及该树的先序遍历结果。数字间有1个空格，行末不得有多余空格。\n\n### 输入样例:\n```in\n7\n2 3 1 5 7 6 4\n1 2 3 4 5 6 7\n```\n\n### 输出样例:\n```out\nPreorder: 4 1 3 2 6 5 7\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1327", "description": "本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。\n\n### 输入格式:\n\n第一行给出正整数$$N$$($$\\le 30$$)，是树中结点的个数。随后两行，每行给出$$N$$个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。\n\n### 输出格式:\n\n在一行中输出`Preorder: `以及该树的先序遍历结果。数字间有1个空格，行末不得有多余空格。\n\n### 输入样例:\n```in\n7\n2 3 1 5 7 6 4\n1 2 3 4 5 6 7\n```\n\n### 输出样例:\n```out\nPreorder: 4 1 3 2 6 5 7\n```"}}
{"problemSetProblem": {"id": "6103", "label": "练习4.2", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "平衡二叉树的根", "content": "将给定的一系列数字插入初始为空的AVL树，请你输出最后生成的AVL树的根结点的值。\n\n### 输入格式:\n\n输入的第一行给出一个正整数$$N$$（$$\\le 20$$），随后一行给出$$N$$个不同的整数，其间以空格分隔。\n\n### 输出格式:\n\n在一行中输出顺序插入上述整数到一棵初始为空的AVL树后，该树的根结点的值。\n\n### 输入样例1:\n```in\n5\n88 70 61 96 120\n```\n\n### 输出样例1:\n```out\n70\n```\n\n### 输入样例2:\n```\n7\n88 70 61 96 120 90 65\n```\n\n### 输出样例2:\n```\n88\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1509", "description": "将给定的一系列数字插入初始为空的AVL树，请你输出最后生成的AVL树的根结点的值。\n\n### 输入格式:\n\n输入的第一行给出一个正整数$$N$$（$$\\le 20$$），随后一行给出$$N$$个不同的整数，其间以空格分隔。\n\n### 输出格式:\n\n在一行中输出顺序插入上述整数到一棵初始为空的AVL树后，该树的根结点的值。\n\n### 输入样例1:\n```in\n5\n88 70 61 96 120\n```\n\n### 输出样例1:\n```out\n70\n```\n\n### 输入样例2:\n```\n7\n88 70 61 96 120 90 65\n```\n\n### 输出样例2:\n```\n88\n```"}}
{"problemSetProblem": {"id": "6104", "label": "练习4.3", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "堆中的路径", "content": "将一系列给定数字插入一个初始为空的小顶堆`H[]`。随后对任意给定的下标`i`，打印从`H[i]`到根结点的路径。\n\n### 输入格式:\n\n每组测试第1行包含2个正整数$$N$$和$$M$$($$\\le 1000$$)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的$$N$$个要被插入一个初始为空的小顶堆的整数。最后一行给出$$M$$个下标。\n\n### 输出格式:\n\n对输入中给出的每个下标`i`，在一行中输出从`H[i]`到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。\n\n### 输入样例:\n```in\n5 3\n46 23 26 24 10\n5 4 3\n```\n\n### 输出样例:\n```out\n24 23 10\n46 23 10\n26 10\n```", "type": "PROGRAMMING", "author": "陈越", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "311", "description": "将一系列给定数字插入一个初始为空的小顶堆`H[]`。随后对任意给定的下标`i`，打印从`H[i]`到根结点的路径。\n\n### 输入格式:\n\n每组测试第1行包含2个正整数$$N$$和$$M$$($$\\le 1000$$)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的$$N$$个要被插入一个初始为空的小顶堆的整数。最后一行给出$$M$$个下标。\n\n### 输出格式:\n\n对输入中给出的每个下标`i`，在一行中输出从`H[i]`到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。\n\n### 输入样例:\n```in\n5 3\n46 23 26 24 10\n5 4 3\n```\n\n### 输出样例:\n```out\n24 23 10\n46 23 10\n26 10\n```"}}
{"problemSetProblem": {"id": "6180", "label": "习题4.5", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "顺序存储的二叉树的最近的公共祖先问题", "content": "设顺序存储的二叉树中有编号为$$i$$和$$j$$的两个结点，请设计算法求出它们最近的公共祖先结点的编号和值。\n\n### 输入格式:\n\n输入第1行给出正整数$$n$$（$$\\le 1000$$），即顺序存储的最大容量；第2行给出$$n$$个非负整数，其间以空格分隔。其中0代表二叉树中的空结点（如果第1个结点为0，则代表一棵空树）；第3行给出一对结点编号$$i$$和$$j$$。\n\n题目保证输入正确对应一棵二叉树，且$$1\\le i,j \\le n$$。\n\n### 输出格式:\n\n如果$$i$$或$$j$$对应的是空结点，则输出`ERROR: T[x] is NULL`，其中`x`是$$i$$或$$j$$中先发现错误的那个编号；否则在一行中输出编号为$$i$$和$$j$$的两个结点最近的公共祖先结点的编号和值，其间以1个空格分隔。\n\n### 输入样例1：\n```in\n15\n4 3 5 1 10 0 7 0 2 0 9 0 0 6 8\n11 4\n```\n\n### 输出样例1：\n```out\n2 3\n```\n\n### 输入样例2：\n```\n15\n4 3 5 1 0 0 7 0 2 0 9 0 0 6 8\n12 8\n```\n\n### 输出样例2：\n```\nERROR: T[12] is NULL\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1523", "description": "设顺序存储的二叉树中有编号为$$i$$和$$j$$的两个结点，请设计算法求出它们最近的公共祖先结点的编号和值。\n\n### 输入格式:\n\n输入第1行给出正整数$$n$$（$$\\le 1000$$），即顺序存储的最大容量；第2行给出$$n$$个非负整数，其间以空格分隔。其中0代表二叉树中的空结点（如果第1个结点为0，则代表一棵空树）；第3行给出一对结点编号$$i$$和$$j$$。\n\n题目保证输入正确对应一棵二叉树，且$$1\\le i,j \\le n$$。\n\n### 输出格式:\n\n如果$$i$$或$$j$$对应的是空结点，则输出`ERROR: T[x] is NULL`，其中`x`是$$i$$或$$j$$中先发现错误的那个编号；否则在一行中输出编号为$$i$$和$$j$$的两个结点最近的公共祖先结点的编号和值，其间以1个空格分隔。\n\n### 输入样例1：\n```in\n15\n4 3 5 1 10 0 7 0 2 0 9 0 0 6 8\n11 4\n```\n\n### 输出样例1：\n```out\n2 3\n```\n\n### 输入样例2：\n```\n15\n4 3 5 1 0 0 7 0 2 0 9 0 0 6 8\n12 8\n```\n\n### 输出样例2：\n```\nERROR: T[12] is NULL\n```"}}
{"problemSetProblem": {"id": "6259", "label": "习题5.13", "score": 30, "problemConfig": {"programmingProblemConfig": {"timeLimit": 2000, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "词频统计", "content": "请编写程序，对一段英文文本，统计其中所有不同单词的个数，以及词频最大的前10%的单词。\n\n所谓“单词”，是指由不超过80个单词字符组成的连续字符串，但长度超过15的单词将只截取保留前15个单词字符。而合法的“单词字符”为大小写字母、数字和下划线，其它字符均认为是单词分隔符。\n\n### 输入格式:\n\n输入给出一段非空文本，最后以符号`#`结尾。输入保证存在至少10个不同的单词。\n\n### 输出格式:\n\n在第一行中输出文本中所有不同单词的个数。注意“单词”不区分英文大小写，例如“PAT”和“pat”被认为是同一个单词。\n\n随后按照词频递减的顺序，按照`词频:单词`的格式输出词频最大的前10%的单词。若有并列，则按递增字典序输出。\n\n### 输入样例：\n```in\nThis is a test.\n\nThe word \"this\" is the word with the highest frequency.\n\nLonglonglonglongword should be cut off, so is considered as the same as longlonglonglonee.  But this_8 is different than this, and this, and this...#\nthis line should be ignored.\n```\n\n### 输出样例：（注意：虽然单词`the`也出现了4次，但因为我们只要输出前10%（即23个单词中的前2个）单词，而按照字母序，`the`排第3位，所以不输出。）\n```out\n23\n5:this\n4:is\n```\n\n### 感谢武汉理工大学的郭小兵老师修正测试数据！", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1526", "description": "请编写程序，对一段英文文本，统计其中所有不同单词的个数，以及词频最大的前10%的单词。\n\n所谓“单词”，是指由不超过80个单词字符组成的连续字符串，但长度超过15的单词将只截取保留前15个单词字符。而合法的“单词字符”为大小写字母、数字和下划线，其它字符均认为是单词分隔符。\n\n### 输入格式:\n\n输入给出一段非空文本，最后以符号`#`结尾。输入保证存在至少10个不同的单词。\n\n### 输出格式:\n\n在第一行中输出文本中所有不同单词的个数。注意“单词”不区分英文大小写，例如“PAT”和“pat”被认为是同一个单词。\n\n随后按照词频递减的顺序，按照`词频:单词`的格式输出词频最大的前10%的单词。若有并列，则按递增字典序输出。\n\n### 输入样例：\n```in\nThis is a test.\n\nThe word \"this\" is the word with the highest frequency.\n\nLonglonglonglongword should be cut off, so is considered as the same as longlonglonglonee.  But this_8 is different than this, and this, and this...#\nthis line should be ignored.\n```\n\n### 输出样例：（注意：虽然单词`the`也出现了4次，但因为我们只要输出前10%（即23个单词中的前2个）单词，而按照字母序，`the`排第3位，所以不输出。）\n```out\n23\n5:this\n4:is\n```\n\n### 感谢武汉理工大学的郭小兵老师修正测试数据！"}}
{"problemSetProblem": {"id": "6476", "label": "实例6.1", "score": 30, "problemConfig": {"programmingProblemConfig": {"timeLimit": 2500, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [{"name": "", "input": "10 9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n", "output": "1: 70.00%\n2: 80.00%\n3: 90.00%\n4: 100.00%\n5: 100.00%\n6: 100.00%\n7: 100.00%\n8: 90.00%\n9: 80.00%\n10: 70.00%\n"}, {"name": "", "input": "10 9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n", "output": "1: 70.00%\n2: 80.00%\n3: 90.00%\n4: 100.00%\n5: 100.00%\n6: 100.00%\n7: 100.00%\n8: 90.00%\n9: 80.00%\n10: 70.00%\n"}], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "六度空间", "content": "“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。\n\n<center>\n![](~/35)<br>\n图1  六度空间示意图</center>\n\n“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。\n\n假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。\n\n### 输入格式:\n\n输入第1行给出两个正整数，分别表示社交网络图的结点数$$N$$（$$1<N\\le 10^3$$，表示人数）、边数$$M$$（$$\\le 33\\times N$$，表示社交关系数）。随后的$$M$$行对应$$M$$条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到$$N$$编号）。\n\n### 输出格式:\n\n对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。\n\n### 输入样例:\n```in\n10 9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n```\n\n### 输出样例:\n```out\n1: 70.00%\n2: 80.00%\n3: 90.00%\n4: 100.00%\n5: 100.00%\n6: 100.00%\n7: 100.00%\n8: 90.00%\n9: 80.00%\n10: 70.00%\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "316", "description": "“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。\n\n<center>\n![](~/35)<br>\n图1  六度空间示意图</center>\n\n“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。\n\n假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。\n\n### 输入格式:\n\n输入第1行给出两个正整数，分别表示社交网络图的结点数$$N$$（$$1<N\\le 10^3$$，表示人数）、边数$$M$$（$$\\le 33\\times N$$，表示社交关系数）。随后的$$M$$行对应$$M$$条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到$$N$$编号）。\n\n### 输出格式:\n\n对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。\n\n### 输入样例:\n```in\n10 9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n```\n\n### 输出样例:\n```out\n1: 70.00%\n2: 80.00%\n3: 90.00%\n4: 100.00%\n5: 100.00%\n6: 100.00%\n7: 100.00%\n8: 90.00%\n9: 80.00%\n10: 70.00%\n```"}}
{"problemSetProblem": {"id": "6477", "label": "练习7.1", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 10000, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "排序", "content": "给定$$N$$个（长整型范围内的）整数，要求输出从小到大排序后的结果。\n\n本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：\n\n<li>数据1：只有1个元素；\n<li>数据2：11个不相同的整数，测试基本正确性；\n<li>数据3：10<sup>3</sup>个随机整数；\n<li>数据4：10<sup>4</sup>个随机整数；\n<li>数据5：10<sup>5</sup>个随机整数；\n<li>数据6：10<sup>5</sup>个顺序整数；\n<li>数据7：10<sup>5</sup>个逆序整数；\n<li>数据8：10<sup>5</sup>个基本有序的整数；\n<li>数据9：10<sup>5</sup>个随机正整数，每个数字不超过1000。\n\n\n### 输入格式:\n\n输入第一行给出正整数$$N$$（$$\\le 10^5$$），随后一行给出$$N$$个（长整型范围内的）整数，其间以空格分隔。\n\n### 输出格式:\n\n在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。\n\n### 输入样例:\n```in\n11\n4 981 10 -17 0 -20 29 50 8 43 -5\n```\n\n### 输出样例:\n```out\n-20 -17 -5 0 4 8 10 29 43 50 981\n```", "type": "PROGRAMMING", "author": "陈越", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "323", "description": "给定$$N$$个（长整型范围内的）整数，要求输出从小到大排序后的结果。\n\n本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：\n\n<li>数据1：只有1个元素；\n<li>数据2：11个不相同的整数，测试基本正确性；\n<li>数据3：10<sup>3</sup>个随机整数；\n<li>数据4：10<sup>4</sup>个随机整数；\n<li>数据5：10<sup>5</sup>个随机整数；\n<li>数据6：10<sup>5</sup>个顺序整数；\n<li>数据7：10<sup>5</sup>个逆序整数；\n<li>数据8：10<sup>5</sup>个基本有序的整数；\n<li>数据9：10<sup>5</sup>个随机正整数，每个数字不超过1000。\n\n\n### 输入格式:\n\n输入第一行给出正整数$$N$$（$$\\le 10^5$$），随后一行给出$$N$$个（长整型范围内的）整数，其间以空格分隔。\n\n### 输出格式:\n\n在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。\n\n### 输入样例:\n```in\n11\n4 981 10 -17 0 -20 29 50 8 43 -5\n```\n\n### 输出样例:\n```out\n-20 -17 -5 0 4 8 10 29 43 50 981\n```"}}
{"problemSetProblem": {"id": "6495", "label": "习题8.1", "score": 25, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [{"name": "", "input": "9\n0 20\n1 15\n1 61\n2 10\n10 5\n10 3\n30 18\n31 25\n31 2\n3\n", "output": "6.2 17 61\n5 3 1\n"}, {"name": "", "input": "9\n0 20\n1 15\n1 61\n2 10\n10 5\n10 3\n30 18\n31 25\n31 2\n3\n", "output": "6.2 17 61\n5 3 1\n"}], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "银行排队问题之单队列多窗口服务", "content": "假设银行有$$K$$个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。当有多个窗口可选择时，假设顾客总是选择编号最小的窗口。\n\n本题要求输出前来等待服务的$$N$$位顾客的平均等待时间、最长等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。\n\n### 输入格式:\n\n输入第1行给出正整数$$N$$（$$\\le 1000$$），为顾客总人数；随后$$N$$行，每行给出一位顾客的到达时间`T`和事务处理时间`P`，并且假设输入数据已经按到达时间先后排好了顺序；最后一行给出正整数$$K$$（$$\\le 10$$），为开设的营业窗口数。这里假设每位顾客事务被处理的最长时间为60分钟。 \n\n### 输出格式:\n\n在第一行中输出平均等待时间（输出到小数点后1位）、最长等待时间、最后完成时间，之间用1个空格分隔，行末不能有多余空格。\n\n在第二行中按编号递增顺序输出每个窗口服务了多少名顾客，数字之间用1个空格分隔，行末不能有多余空格。\n\n### 输入样例：\n```in\n9\n0 20\n1 15\n1 61\n2 10\n10 5\n10 3\n30 18\n31 25\n31 2\n3\n```\n\n### 输出样例：\n```out\n6.2 17 61\n5 3 1\n```\n\n###感谢浙江财经大学王瑞洲、周甄陶同学修正测试数据！", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1530", "description": "假设银行有$$K$$个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。当有多个窗口可选择时，假设顾客总是选择编号最小的窗口。\n\n本题要求输出前来等待服务的$$N$$位顾客的平均等待时间、最长等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。\n\n### 输入格式:\n\n输入第1行给出正整数$$N$$（$$\\le 1000$$），为顾客总人数；随后$$N$$行，每行给出一位顾客的到达时间`T`和事务处理时间`P`，并且假设输入数据已经按到达时间先后排好了顺序；最后一行给出正整数$$K$$（$$\\le 10$$），为开设的营业窗口数。这里假设每位顾客事务被处理的最长时间为60分钟。 \n\n### 输出格式:\n\n在第一行中输出平均等待时间（输出到小数点后1位）、最长等待时间、最后完成时间，之间用1个空格分隔，行末不能有多余空格。\n\n在第二行中按编号递增顺序输出每个窗口服务了多少名顾客，数字之间用1个空格分隔，行末不能有多余空格。\n\n### 输入样例：\n```in\n9\n0 20\n1 15\n1 61\n2 10\n10 5\n10 3\n30 18\n31 25\n31 2\n3\n```\n\n### 输出样例：\n```out\n6.2 17 61\n5 3 1\n```\n\n###感谢浙江财经大学王瑞洲、周甄陶同学修正测试数据！"}}
{"problemSetProblem": {"id": "6516", "label": "习题8.2", "score": 30, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [{"name": "", "input": "10\n0 20 0\n0 20 0\n1 68 1\n1 12 1\n2 15 0\n2 10 0\n3 15 1\n10 12 1\n30 15 0\n62 5 1\n3 1\n", "output": "15.1 35 67\n4 5 1\n"}, {"name": "", "input": "10\n0 20 0\n0 20 0\n1 68 1\n1 12 1\n2 15 0\n2 10 0\n3 15 1\n10 12 1\n30 15 0\n62 5 1\n3 1\n", "output": "15.1 35 67\n4 5 1\n"}], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "银行排队问题之单队列多窗口加VIP服务", "content": "假设银行有$$K$$个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。当有多个窗口可选择时，假设顾客总是选择编号最小的窗口。\n\n有些银行会给VIP客户以各种优惠服务，例如专门开辟VIP窗口。为了最大限度地利用资源，VIP窗口的服务机制定义为：当队列中没有VIP客户时，该窗口为普通顾客服务；当该窗口空闲并且队列中有VIP客户在等待时，排在最前面的VIP客户享受该窗口的服务。同时，当轮到某VIP客户出列时，若VIP窗口非空，该客户可以选择空闲的普通窗口；**否则一定选择VIP窗口**。\n\n本题要求输出前来等待服务的$$N$$位顾客的平均等待时间、最长等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。\n\n### 输入格式:\n\n输入第1行给出正整数$$N$$（$$\\le 1000$$），为顾客总人数；随后$$N$$行，每行给出一位顾客的到达时间`T`、事务处理时间`P`和是否VIP的标志（1是VIP，0则不是），并且假设输入数据已经按到达时间先后排好了顺序；最后一行给出正整数$$K$$（$$\\le 10$$）—— 为开设的营业窗口数，以及VIP窗口的编号（从0到$$K-1$$）。这里假设每位顾客事务被处理的最长时间为60分钟。 \n\n### 输出格式:\n\n在第一行中输出平均等待时间（输出到小数点后1位）、最长等待时间、最后完成时间，之间用1个空格分隔，行末不能有多余空格。\n\n在第二行中按编号递增顺序输出每个窗口服务了多少名顾客，数字之间用1个空格分隔，行末不能有多余空格。\n\n### 输入样例：\n```in\n10\n0 20 0\n0 20 0\n1 68 1\n1 12 1\n2 15 0\n2 10 0\n3 15 1\n10 12 1\n30 15 0\n62 5 1\n3 1\n```\n\n### 输出样例：\n```out\n15.1 35 67\n4 5 1\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1534", "description": "假设银行有$$K$$个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。当有多个窗口可选择时，假设顾客总是选择编号最小的窗口。\n\n有些银行会给VIP客户以各种优惠服务，例如专门开辟VIP窗口。为了最大限度地利用资源，VIP窗口的服务机制定义为：当队列中没有VIP客户时，该窗口为普通顾客服务；当该窗口空闲并且队列中有VIP客户在等待时，排在最前面的VIP客户享受该窗口的服务。同时，当轮到某VIP客户出列时，若VIP窗口非空，该客户可以选择空闲的普通窗口；**否则一定选择VIP窗口**。\n\n本题要求输出前来等待服务的$$N$$位顾客的平均等待时间、最长等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。\n\n### 输入格式:\n\n输入第1行给出正整数$$N$$（$$\\le 1000$$），为顾客总人数；随后$$N$$行，每行给出一位顾客的到达时间`T`、事务处理时间`P`和是否VIP的标志（1是VIP，0则不是），并且假设输入数据已经按到达时间先后排好了顺序；最后一行给出正整数$$K$$（$$\\le 10$$）—— 为开设的营业窗口数，以及VIP窗口的编号（从0到$$K-1$$）。这里假设每位顾客事务被处理的最长时间为60分钟。 \n\n### 输出格式:\n\n在第一行中输出平均等待时间（输出到小数点后1位）、最长等待时间、最后完成时间，之间用1个空格分隔，行末不能有多余空格。\n\n在第二行中按编号递增顺序输出每个窗口服务了多少名顾客，数字之间用1个空格分隔，行末不能有多余空格。\n\n### 输入样例：\n```in\n10\n0 20 0\n0 20 0\n1 68 1\n1 12 1\n2 15 0\n2 10 0\n3 15 1\n10 12 1\n30 15 0\n62 5 1\n3 1\n```\n\n### 输出样例：\n```out\n15.1 35 67\n4 5 1\n```"}}
{"problemSetProblem": {"id": "6541", "label": "习题8.3", "score": 30, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "银行排队问题之单窗口“夹塞”版", "content": "排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行的单窗口排队问题中，假设银行只有1个窗口提供服务，所有顾客按到达时间排成一条长龙。当窗口空闲时，下一位顾客即去该窗口处理事务。此时如果已知第$$i$$位顾客与排在后面的第$$j$$位顾客是好朋友，并且愿意替朋友办理事务的话，那么第$$i$$位顾客的事务处理时间就是自己的事务加朋友的事务所耗时间的总和。在这种情况下，顾客的等待时间就可能被影响。假设所有人到达银行时，若没有空窗口，都会请求排在最前面的朋友帮忙（包括正在窗口接受服务的朋友）；当有不止一位朋友请求某位顾客帮忙时，该顾客会根据自己朋友请求的顺序来依次处理事务。试编写程序模拟这种现象，并计算顾客的平均等待时间。\n\n### 输入格式:\n\n输入的第一行是两个整数：$$1\\le N \\le 10000$$，为顾客总数；$$0 \\le M \\le 100$$，为彼此不相交的朋友圈子个数。若$$M$$非0，则此后$$M$$行，每行先给出正整数$$2\\le L \\le 100$$，代表该圈子里朋友的总数，随后给出该朋友圈里的$$L$$位朋友的名字。名字由3个大写英文字母组成，名字间用1个空格分隔。最后$$N$$行给出$$N$$位顾客的姓名、到达时间$$T$$和事务处理时间$$P$$（以分钟为单位），之间用1个空格分隔。简单起见，这里假设顾客信息是按照到达时间先后顺序给出的（有并列时间的按照给出顺序排队），并且假设每个事务最多占用窗口服务60分钟（如果超过则按60分钟计算）。\n\n### 输出格式:\n\n按顾客接受服务的顺序输出顾客名字，每个名字占1行。最后一行输出所有顾客的平均等待时间，保留到小数点后1位。\n\n### 输入样例:\n```in\n6 2\n3 ANN BOB JOE\n2 JIM ZOE\nJIM 0 20\nBOB 0 15\nANN 0 30\nAMY 0 2\nZOE 1 61\nJOE 3 10\n```\n\n### 输出样例:\n```out\nJIM\nZOE\nBOB\nANN\nJOE\nAMY\n75.2\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "635", "description": "排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行的单窗口排队问题中，假设银行只有1个窗口提供服务，所有顾客按到达时间排成一条长龙。当窗口空闲时，下一位顾客即去该窗口处理事务。此时如果已知第$$i$$位顾客与排在后面的第$$j$$位顾客是好朋友，并且愿意替朋友办理事务的话，那么第$$i$$位顾客的事务处理时间就是自己的事务加朋友的事务所耗时间的总和。在这种情况下，顾客的等待时间就可能被影响。假设所有人到达银行时，若没有空窗口，都会请求排在最前面的朋友帮忙（包括正在窗口接受服务的朋友）；当有不止一位朋友请求某位顾客帮忙时，该顾客会根据自己朋友请求的顺序来依次处理事务。试编写程序模拟这种现象，并计算顾客的平均等待时间。\n\n### 输入格式:\n\n输入的第一行是两个整数：$$1\\le N \\le 10000$$，为顾客总数；$$0 \\le M \\le 100$$，为彼此不相交的朋友圈子个数。若$$M$$非0，则此后$$M$$行，每行先给出正整数$$2\\le L \\le 100$$，代表该圈子里朋友的总数，随后给出该朋友圈里的$$L$$位朋友的名字。名字由3个大写英文字母组成，名字间用1个空格分隔。最后$$N$$行给出$$N$$位顾客的姓名、到达时间$$T$$和事务处理时间$$P$$（以分钟为单位），之间用1个空格分隔。简单起见，这里假设顾客信息是按照到达时间先后顺序给出的（有并列时间的按照给出顺序排队），并且假设每个事务最多占用窗口服务60分钟（如果超过则按60分钟计算）。\n\n### 输出格式:\n\n按顾客接受服务的顺序输出顾客名字，每个名字占1行。最后一行输出所有顾客的平均等待时间，保留到小数点后1位。\n\n### 输入样例:\n```in\n6 2\n3 ANN BOB JOE\n2 JIM ZOE\nJIM 0 20\nBOB 0 15\nANN 0 30\nAMY 0 2\nZOE 1 61\nJOE 3 10\n```\n\n### 输出样例:\n```out\nJIM\nZOE\nBOB\nANN\nJOE\nAMY\n75.2\n```"}}
{"problemSetProblem": {"id": "6544", "label": "习题8.4", "score": 30, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "畅通工程之最低成本建设问题", "content": "某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了有可能建设成快速路的若干条道路的成本，求畅通工程需要的最低成本。\n\n### 输入格式:\n\n输入的第一行给出城镇数目$$N$$ ($$1< N \\le 1000$$)和候选道路数目$$M\\le 3N$$；随后的$$M$$行，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号（从1编号到$$N$$）以及该道路改建的预算成本。\n\n### 输出格式:\n\n输出畅通工程需要的最低成本。如果输入数据不足以保证畅通，则输出“Impossible”。\n\n### 输入样例1:\n```in\n6 15\n1 2 5\n1 3 3\n1 4 7\n1 5 4\n1 6 2\n2 3 4\n2 4 6\n2 5 2\n2 6 6\n3 4 6\n3 5 1\n3 6 1\n4 5 10\n4 6 8\n5 6 3\n```\n\n### 输出样例1:\n```out\n12\n```\n\n### 输入样例2:\n```\n5 4\n1 2 1\n2 3 2\n3 1 3\n4 5 4\n```\n\n### 输出样例2:\n```\nImpossible\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "1538", "description": "某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了有可能建设成快速路的若干条道路的成本，求畅通工程需要的最低成本。\n\n### 输入格式:\n\n输入的第一行给出城镇数目$$N$$ ($$1< N \\le 1000$$)和候选道路数目$$M\\le 3N$$；随后的$$M$$行，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号（从1编号到$$N$$）以及该道路改建的预算成本。\n\n### 输出格式:\n\n输出畅通工程需要的最低成本。如果输入数据不足以保证畅通，则输出“Impossible”。\n\n### 输入样例1:\n```in\n6 15\n1 2 5\n1 3 3\n1 4 7\n1 5 4\n1 6 2\n2 3 4\n2 4 6\n2 5 2\n2 6 6\n3 4 6\n3 5 1\n3 6 1\n4 5 10\n4 6 8\n5 6 3\n```\n\n### 输出样例1:\n```out\n12\n```\n\n### 输入样例2:\n```\n5 4\n1 2 1\n2 3 2\n3 1 3\n4 5 4\n```\n\n### 输出样例2:\n```\nImpossible\n```"}}
{"problemSetProblem": {"id": "6542", "label": "习题8.5", "score": 35, "problemConfig": {"programmingProblemConfig": {"timeLimit": 400, "memoryLimit": 65536, "codeSizeLimit": 16, "cases": {}, "exampleTestDatas": [], "testdataDescriptionCode": "", "customizeLimits": [], "stackSizeLimit": 0}, "solutionVisible": false}, "deadline": "1970-01-01T00:00:00Z", "title": "畅通工程之局部最小花费问题", "content": "某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建快速路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全地区畅通需要的最低成本。\n\n### 输入格式:\n\n输入的第一行给出村庄数目$$N$$ ($$1\\le N \\le 100$$)；随后的$$N(N-1)/2$$行对应村庄间道路的成本及修建状态：每行给出4个正整数，分别是两个村庄的编号（从1编号到$$N$$），此两村庄间道路的成本，以及修建状态 — 1表示已建，0表示未建。\n\n### 输出格式:\n\n输出全省畅通需要的最低成本。\n\n### 输入样例:\n```in\n4\n1 2 1 1\n1 3 4 0\n1 4 1 1\n2 3 3 0\n2 4 2 1\n3 4 5 0\n```\n\n### 输出样例:\n```out\n3\n```", "type": "PROGRAMMING", "author": "DS课程组", "authorOrganization": {"id": "1", "name": "浙江大学", "comment": "", "code": "", "country": "NO_COUNTRY", "membersCount": 0, "type": "UNKNOWN", "balance": 0, "subdomain": "", "logo": ""}, "compiler": "NO_COMPILER", "problemStatus": "REVIEWED", "lastSubmissionId": "0", "solution": "", "problemSetId": "434", "problemId": "637", "description": "某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建快速路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全地区畅通需要的最低成本。\n\n### 输入格式:\n\n输入的第一行给出村庄数目$$N$$ ($$1\\le N \\le 100$$)；随后的$$N(N-1)/2$$行对应村庄间道路的成本及修建状态：每行给出4个正整数，分别是两个村庄的编号（从1编号到$$N$$），此两村庄间道路的成本，以及修建状态 — 1表示已建，0表示未建。\n\n### 输出格式:\n\n输出全省畅通需要的最低成本。\n\n### 输入样例:\n```in\n4\n1 2 1 1\n1 3 4 0\n1 4 1 1\n2 3 3 0\n2 4 2 1\n3 4 5 0\n```\n\n### 输出样例:\n```out\n3\n```"}}
